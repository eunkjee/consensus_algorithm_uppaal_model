<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE nta PUBLIC '-//Uppaal Team//DTD Flat System 1.1//EN' 'http://www.it.uu.se/research/group/darts/uppaal/flat-1_2.dtd'>
<nta>
	<declaration>const int N = 5; // total number of nodes
const int F = 0; // total number of faulty nodes
typedef int[0,N-F-1] n_id;
//typedef int[N-F,N-1] f_id;

const int THR = 100; // quorum threshold number

const int V = 3; // maximum number of values in nomination state
typedef int[0,V-1] v_id;
const int ZEROCOUNTER = 0;
const bool NOVALUE[V] =
    {false, false, false};

const int SLOTMAX = V-1;
typedef int[0,SLOTMAX] s_id;

const int INFINITY = 15;
const int INTERVAL = 20;
const int MAXCNT = 14;
//modified by jyoo 20210405
const int MAXGAP_NODE = 1;
//added by jyoo 20210308
const int MAXGAP_PROTOCOL = 1;

// states
const int SCPPrepare = 0;
const int SCPCommit = 1;
const int SCPExternalize = 2;
//const int SCPNomination = 3;

chan sthNominated[N-F];
chan nominationDone[N-F];
//broadcast chan slotDone;
broadcast chan slotSuccess;
broadcast chan slotFail;
broadcast chan slotTimeout;
broadcast chan slotStarted[SLOTMAX+1];

typedef struct {
    int[0,N] threshold;
    int[0,N] validators[N];
} SCPQuorumSlice;
SCPQuorumSlice qs[V][N] =
// the entire of nodes are in one quorum
    {{{0, {0, 1, 2, 3, 4}}, 
      {0, {0, 1, 2, 3, 4}}, 
      {0, {0, 1, 2, 3, 4}}, 
      {0, {0, 1, 2, 3, 4}},
      {0, {0, 1, 2, 3, 4}}},
     {{0, {0, 1, 2, 3, N}}, 
      {0, {0, 1, 2, 3, N}}, 
      {0, {0, 1, 2, 3, N}}, 
      {0, {0, 1, 2, 3, N}},
      {0, {0, 1, 2, 3, N}}},
     {{0, {0, 1, 2, 3, 4}}, 
      {0, {0, 1, 2, 3, 4}}, 
      {0, {0, 1, 2, 3, 4}}, 
      {0, {0, 1, 2, 3, 4}},
      {0, {0, 1, 2, 3, 4}}}
    };

//    {{{3, {0, 1, 2, N}}, {3, {0, 1, 2, N}}, {3, {0, 1, 2, N}}, {4, {0, 1, 2, 3}}},
//     {{3, {0, 1, 2, N}}, {3, {0, 1, 2, N}}, {3, {0, 1, 2, N}}, {4, {0, 1, 2, 3}}},
//     {{3, {0, 1, 2, N}}, {3, {0, 1, 2, N}}, {3, {0, 1, 2, N}}, {4, {0, 1, 2, 3}}}};

//    {{{3, {0, 1, 2, N}}, {3, {0, 1, 2, N}}, {3, {0, 1, 2, N}}, {1, {N, N, N, 3}}},
//     {{3, {0, 1, 2, N}}, {3, {0, 1, 2, N}}, {3, {0, 1, 2, N}}, {1, {N, N, N, 3}}},
//     {{3, {0, 1, 2, N}}, {3, {0, 1, 2, N}}, {3, {0, 1, 2, N}}, {1, {N, N, N, 3}}}};

//    {{{3, {0, 1, 2, N}}, {3, {0, 1, 2, N}}, {3, {0, 1, 2, N}}, {1, {N, N, N, 3}}},
//     {{3, {0, 1, 2, N}}, {3, {0, 1, 2, N}}, {3, {0, 1, 2, N}}, {4, {0, 1, 2, 3}}},
//     {{3, {0, 1, 2, N}}, {3, {0, 1, 2, N}}, {3, {0, 1, 2, N}}, {1, {N, N, N, 3}}}};

//    {{{3, {0, 1, 2, N}}, {3, {0, 1, 2, N}}, {3, {0, 1, 2, N}}, {1, {N, N, N, 3}}},
//     {{4, {0, 1, 2, 3}}, {4, {0, 1, 2, 3}}, {4, {0, 1, 2, 3}}, {4, {0, 1, 2, 3}}},
//     {{3, {0, 1, 2, N}}, {3, {0, 1, 2, N}}, {3, {0, 1, 2, N}}, {1, {N, N, N, 3}}}};

//removed by jyoo 20201123
//int[0,N] totalValidators[N] =
//    {0, 0, 0, 0};

int[0,SLOTMAX] slotCur = 0;

// faulty nodes should not have any input values!
bool higherlayerInput[N][V] =
    {{true, true, true}, 
     {true, true, true},
     {true, true, true},
     {true, true, true},
     {true, false, true}};

int[0,INFINITY] cur_round[N] =
    {0, 0, 0, 0, 0};

int[0,INFINITY] cur_b_cnt[N] =
    {0, 0, 0, 0, 0};

int[0,INFINITY] tickNomination[N] =
    {0, 0, 0, 0, 0};

int[0,INFINITY] tickBallot[N] =
    {0, 0, 0, 0, 0};

int[0,MAXGAP_PROTOCOL*2] protocolFlip[N] =
    {0, 0, 0, 0, 0};

bool canTick[N] =
    {true, true, true, true, true};

//added by jyoo 20201130
//bool parallelFlip[N] =
//    {true, true, true, true};

typedef struct {
    bool voted[V];
    bool accepted[V];
} SCPNominationState;
SCPNominationState nominationStates[N] =
    {{{false, false, false}, {false, false, false}},
     {{false, false, false}, {false, false, false}},
     {{false, false, false}, {false, false, false}},
     {{false, false, false}, {false, false, false}},
     {{false, false, false}, {false, false, false}}};

bool nominatedValues[N][V] =
    {{false, false, false},
     {false, false, false},
     {false, false, false},
     {false, false, false },
     {false, false, false}};

bool ballotDone[N] =
    {false, false, false, false, false};

typedef struct {
    int[0,INFINITY] counter;
    bool value[V];
} SCPBallot;

typedef struct {
    int[0,2] curState;
    SCPBallot b;
    SCPBallot p;
    SCPBallot pp;
    SCPBallot h;
    SCPBallot c;
} SCPBallotState;
SCPBallotState ballotStates[N];

// check if valueL &lt; valueR
bool isLessValue(const bool &amp;valueL[V], const bool &amp;valueR[V]) {
    int[-1, V-1] i;

    for (i = V-1; i &gt;= 0; i--) {
        if (valueL[i] == false &amp;&amp; valueR[i] == true) {
            return true;
        }
        else if (valueL[i] == true &amp;&amp; valueR[i] == false) {
            return false;
        }
    }
    return false; // valueL == valueR
}

//added by jyoo 20201123
int totalValidators(const int[0,N] curNodeID) {
    int[0,N] totalValidators = 0;

    for (n : int[0,N-1]) {
        if (qs[slotCur][curNodeID].validators[n] != N) {
            totalValidators++;
        }
    }
    return totalValidators;
}

bool canNextRound(const n_id nID) {
    int[0,MAXCNT] min = MAXCNT;

    if (cur_round[nID] == MAXCNT) {
        return false;
    }

    for (n : n_id) {
        if (qs[slotCur][nID].validators[n] != N) {
            if (cur_round[qs[slotCur][nID].validators[n]] &lt;= min) {
                min = cur_round[qs[slotCur][nID].validators[n]];
            }
        }
    }
    return (cur_round[nID] - min) &lt; MAXGAP_NODE;
}

bool canFlipNomination(const n_id nID) {
    return protocolFlip[nID] &gt;= MAXGAP_PROTOCOL &amp;&amp; protocolFlip[nID] &lt;  MAXGAP_PROTOCOL * 2;
}

bool hasGEbCounter(const n_id nID) {
    int[0,INFINITY] min = INFINITY;

    for (n : n_id) {
        if (qs[slotCur][nID].validators[n] != N) {
            if (cur_b_cnt[qs[slotCur][nID].validators[n]] &lt;= min) {
                min = cur_b_cnt[qs[slotCur][nID].validators[n]];
            }
        }
    }

    if ((cur_b_cnt[nID] - min) &lt; MAXGAP_NODE) {
        return true;
    }
    else {
        return false;
    }
}

bool canFlipBallot(const n_id nID) {
    return protocolFlip[nID] &gt;= 0 &amp;&amp; protocolFlip[nID] &lt;  MAXGAP_PROTOCOL;
}

bool tickUpdateDone() {
    for (n : n_id) {
        if (canTick[n]) {
            return false;
        }
    }
    return true;
}

void tickUpdate(const n_id nID) {
    canTick[nID] = false;

    if (tickUpdateDone()) {
        for (n : n_id) {
            if (ballotStates[n].curState != SCPExternalize) {
                canTick[n] = true;
            }
        }
    }
}

//int getCurMaxTick(const int Cur) {
//    int[1, INFINITY] index;
//    int tick = 0;

//    for (index = 1; index &lt;= Cur; index++) {
//        tick += index;
//    }
//    return tick;
//}

////////////////////////////////////
typedef int[0,N-F-1] t_id;
broadcast chan tickManagerStart;
broadcast chan tickManagerStop;
broadcast chan tickStart;
broadcast chan tickStop;
chan tickAdvance[N-F];
chan tickAdvanceDone[N-F];

bool tickReady[N] =
    {true, true, true, true, true};
////////////////////////////////////

chan tickAdvanceBallot[N-F];
chan slotDone;
</declaration>
	<template>
		<name>TickTestApp</name>
		<location id="id0" x="-416" y="-8">
			<committed/>
		</location>
		<location id="id1" x="-230" y="-8">
		</location>
		<location id="id2" x="-68" y="-8">
		</location>
		<location id="id3" x="-68" y="-127">
		</location>
		<location id="id4" x="-68" y="102">
		</location>
		<location id="id5" x="76" y="-187">
		</location>
		<location id="id6" x="76" y="-93">
		</location>
		<location id="id7" x="76" y="-51">
		</location>
		<location id="id8" x="76" y="42">
		</location>
		<location id="id9" x="76" y="85">
		</location>
		<location id="id10" x="76" y="178">
		</location>
		<location id="id11" x="204" y="-187">
			<committed/>
		</location>
		<location id="id12" x="204" y="-93">
			<committed/>
		</location>
		<location id="id13" x="204" y="-51">
			<committed/>
		</location>
		<location id="id14" x="204" y="42">
			<committed/>
		</location>
		<location id="id15" x="204" y="85">
			<committed/>
		</location>
		<location id="id16" x="204" y="178">
			<committed/>
		</location>
		<init ref="id0"/>
		<transition>
			<source ref="id14"/>
			<target ref="id1"/>
			<nail x="263" y="42"/>
			<nail x="263" y="238"/>
			<nail x="-229" y="238"/>
		</transition>
		<transition>
			<source ref="id15"/>
			<target ref="id1"/>
			<nail x="263" y="85"/>
			<nail x="263" y="238"/>
			<nail x="-229" y="238"/>
		</transition>
		<transition>
			<source ref="id16"/>
			<target ref="id1"/>
			<nail x="204" y="238"/>
			<nail x="-229" y="238"/>
		</transition>
		<transition>
			<source ref="id13"/>
			<target ref="id1"/>
			<nail x="263" y="-51"/>
			<nail x="263" y="-263"/>
			<nail x="-229" y="-263"/>
		</transition>
		<transition>
			<source ref="id12"/>
			<target ref="id1"/>
			<nail x="263" y="-93"/>
			<nail x="263" y="-263"/>
			<nail x="-229" y="-263"/>
		</transition>
		<transition>
			<source ref="id11"/>
			<target ref="id1"/>
			<nail x="204" y="-263"/>
			<nail x="-229" y="-263"/>
		</transition>
		<transition>
			<source ref="id10"/>
			<target ref="id16"/>
			<label kind="synchronisation" x="94" y="161">tickAdvance[0]?</label>
		</transition>
		<transition>
			<source ref="id9"/>
			<target ref="id15"/>
			<label kind="synchronisation" x="94" y="68">tickAdvance[1]?</label>
		</transition>
		<transition>
			<source ref="id8"/>
			<target ref="id14"/>
			<label kind="synchronisation" x="94" y="25">tickAdvance[0]?</label>
		</transition>
		<transition>
			<source ref="id7"/>
			<target ref="id13"/>
			<label kind="synchronisation" x="94" y="-68">tickAdvance[2]?</label>
		</transition>
		<transition>
			<source ref="id6"/>
			<target ref="id12"/>
			<label kind="synchronisation" x="94" y="-110">tickAdvance[1]?</label>
		</transition>
		<transition>
			<source ref="id5"/>
			<target ref="id11"/>
			<label kind="synchronisation" x="94" y="-204">tickAdvance[2]?</label>
		</transition>
		<transition>
			<source ref="id4"/>
			<target ref="id10"/>
			<label kind="synchronisation" x="-50" y="123">tickAdvance[1]?</label>
		</transition>
		<transition>
			<source ref="id4"/>
			<target ref="id9"/>
			<label kind="synchronisation" x="-50" y="76">tickAdvance[0]?</label>
		</transition>
		<transition>
			<source ref="id2"/>
			<target ref="id8"/>
			<label kind="synchronisation" x="-50" y="0">tickAdvance[2]?</label>
		</transition>
		<transition>
			<source ref="id2"/>
			<target ref="id7"/>
			<label kind="synchronisation" x="-50" y="-46">tickAdvance[0]?</label>
		</transition>
		<transition>
			<source ref="id3"/>
			<target ref="id6"/>
			<label kind="synchronisation" x="-50" y="-127">tickAdvance[2]?</label>
		</transition>
		<transition>
			<source ref="id3"/>
			<target ref="id5"/>
			<label kind="synchronisation" x="-50" y="-174">tickAdvance[1]?</label>
		</transition>
		<transition>
			<source ref="id1"/>
			<target ref="id4"/>
			<label kind="synchronisation" x="-212" y="30">tickAdvance[2]?</label>
		</transition>
		<transition>
			<source ref="id1"/>
			<target ref="id2"/>
			<label kind="synchronisation" x="-212" y="-25">tickAdvance[1]?</label>
		</transition>
		<transition>
			<source ref="id1"/>
			<target ref="id3"/>
			<label kind="synchronisation" x="-212" y="-84">tickAdvance[0]?</label>
		</transition>
		<transition>
			<source ref="id0"/>
			<target ref="id1"/>
			<label kind="synchronisation" x="-398" y="-25">tickManagerStart!</label>
		</transition>
	</template>
	<template>
		<name>TickManager</name>
		<declaration>bool isDone() {
    for (t : t_id) {
        if (tickReady[t] == true) {
            return false;
        }
    }
    return true;
}

void resetTick() {
    for (t : t_id) {
        tickReady[t] = true;
    }
}
</declaration>
		<location id="id17" x="-382" y="-8">
		</location>
		<location id="id18" x="-144" y="-8">
			<committed/>
		</location>
		<location id="id19" x="85" y="-8">
		</location>
		<location id="id20" x="-144" y="-153">
			<committed/>
		</location>
		<init ref="id17"/>
		<transition>
			<source ref="id19"/>
			<target ref="id20"/>
			<label kind="synchronisation" x="-127" y="-280">slotTimeout?</label>
			<nail x="85" y="-289"/>
			<nail x="-144" y="-289"/>
		</transition>
		<transition>
			<source ref="id19"/>
			<target ref="id20"/>
			<label kind="synchronisation" x="-127" y="-212">slotFail?</label>
			<nail x="85" y="-221"/>
			<nail x="-144" y="-221"/>
		</transition>
		<transition>
			<source ref="id20"/>
			<target ref="id17"/>
			<label kind="synchronisation" x="-365" y="-144">tickStop!</label>
			<label kind="assignment" x="-365" y="-127">resetTick()</label>
			<nail x="-382" y="-153"/>
		</transition>
		<transition>
			<source ref="id19"/>
			<target ref="id20"/>
			<label kind="synchronisation" x="-127" y="-144">slotSuccess?</label>
			<nail x="85" y="-153"/>
		</transition>
		<transition>
			<source ref="id19"/>
			<target ref="id19"/>
			<label kind="guard" x="170" y="-34">isDone()</label>
			<label kind="assignment" x="170" y="0">resetTick()</label>
			<nail x="161" y="-68"/>
			<nail x="161" y="51"/>
		</transition>
		<transition>
			<source ref="id18"/>
			<target ref="id19"/>
			<label kind="synchronisation" x="-126" y="-25">tickStart!</label>
		</transition>
		<transition>
			<source ref="id17"/>
			<target ref="id18"/>
			<label kind="synchronisation" x="-364" y="-25">slotStarted[slotCur]?</label>
		</transition>
	</template>
	<template>
		<name>TickWorker</name>
		<parameter>const t_id tickID</parameter>
		<location id="id21" x="-306" y="0">
		</location>
		<location id="id22" x="-85" y="0">
		</location>
		<location id="id23" x="161" y="0">
		</location>
		<init ref="id21"/>
		<transition>
			<source ref="id23"/>
			<target ref="id22"/>
			<label kind="synchronisation" x="-25" y="85">tickAdvanceDone[tickID]?</label>
			<label kind="assignment" x="-25" y="102">tickReady[tickID] = false</label>
			<nail x="42" y="85"/>
		</transition>
		<transition>
			<source ref="id22"/>
			<target ref="id23"/>
			<label kind="guard" x="-42" y="-135">tickReady[tickID] == true</label>
			<label kind="synchronisation" x="-42" y="-118">tickAdvance[tickID]!</label>
			<nail x="42" y="-93"/>
		</transition>
		<transition>
			<source ref="id22"/>
			<target ref="id21"/>
			<label kind="synchronisation" x="-289" y="-102">tickStop?</label>
			<nail x="-85" y="-110"/>
			<nail x="-306" y="-110"/>
		</transition>
		<transition>
			<source ref="id21"/>
			<target ref="id22"/>
			<label kind="synchronisation" x="-289" y="-25">tickStart?</label>
		</transition>
	</template>
	<template>
		<name>NodeBallot</name>
		<parameter>const n_id nodeID</parameter>
		<declaration>//clock n_clockBCounter;

//bool canFlipBallot() {
//    return protocolFlip[nodeID] &gt;= 0 &amp;&amp; protocolFlip[nodeID] &lt;  MAXGAP_PROTOCOL;
//}

void updateFlipBallot() {
    if (canFlipBallot(nodeID) &amp;&amp; ballotStates[nodeID].curState != SCPExternalize) {
        protocolFlip[nodeID]++;
    }
}

void updatebValue() {
    if (ballotStates[nodeID].h.value != NOVALUE) {
        ballotStates[nodeID].b.value = ballotStates[nodeID].h.value;
    }
    else if (nominatedValues[nodeID] != NOVALUE) {
        //modified by jyoo 20201123
        //if (ballotStates[nodeID].b.value != nominatedValues[nodeID]) {
        //    ballotStates[nodeID].b.value = nominatedValues[nodeID];
        //}
        for (v : v_id) {
            if (nominatedValues[nodeID][v] == true &amp;&amp; ballotStates[nodeID].b.value[v] == false) {
                ballotStates[nodeID].b.value[v] = true;
                return;
            }
        }
    }
    else if (ballotStates[nodeID].p.value != NOVALUE) {
        ballotStates[nodeID].b.value = ballotStates[nodeID].p.value;
    }
}

void resetBallotState() {
    cur_b_cnt[nodeID] = 0;
    tickBallot[nodeID] = 0;
    ballotDone[nodeID] = false;

    ballotStates[nodeID].curState = SCPPrepare;
    ballotStates[nodeID].b.counter = 0;
    ballotStates[nodeID].b.value = NOVALUE;
    ballotStates[nodeID].p.counter = 0;
    ballotStates[nodeID].p.value = NOVALUE;
    ballotStates[nodeID].pp.counter = 0;
    ballotStates[nodeID].pp.value = NOVALUE;
    ballotStates[nodeID].h.counter = 0;
    ballotStates[nodeID].h.value = NOVALUE;
    ballotStates[nodeID].c.counter = 0;
    ballotStates[nodeID].c.value = NOVALUE;
}

void initBallotState() {
    cur_b_cnt[nodeID] = 1;
    ballotStates[nodeID].b.counter = 1;
    //modified by jyoo 20201123
    //ballotStates[nodeID].b.value = nominatedValues[nodeID];
    for (v : v_id) {
        if (nominatedValues[nodeID][v] == true &amp;&amp; ballotStates[nodeID].b.value[v] == false) {
            ballotStates[nodeID].b.value[v] = true;
            return;
        }
    }
}

//bool hasGEbCounter() {
////    bool hasCounter = false;
//    int[0,INFINITY] min = INFINITY;

//    for (n : n_id) {
//        if (qs[slotCur][nodeID].validators[n] != N) {
////            if (qs[slotCur][nodeID].validators[n] != nodeID
////                &amp;&amp; cur_b_cnt[qs[slotCur][nodeID].validators[n]] &gt;= cur_b_cnt[nodeID]) {
////                hasCounter = true;
////            }

//            if (cur_b_cnt[qs[slotCur][nodeID].validators[n]] &lt;= min) {
//                min = cur_b_cnt[qs[slotCur][nodeID].validators[n]];
//            }
//        }
//    }

////    if (hasCounter
////        &amp;&amp; (cur_b_cnt[nodeID] - min) &lt; MAXGAP) {
//    if ((cur_b_cnt[nodeID] - min) &lt; MAXGAP_NODE) {
//        return true;
//    }
//    else {
//        return false;
//    }
//}

bool checkAcceptedPrepareQuorum(int[0,N] nodeIndex, const SCPBallot &amp;candidate) {
    int[0,N] cntQuorumTH = 0;
    bool isVBlocked = false;

    for (n : int[0,N-1]) {
        if (N - n + cntQuorumTH &lt; qs[slotCur][nodeIndex].threshold) {
            return false;
        }
        if (qs[slotCur][nodeIndex].validators[n] != N) {
            isVBlocked = false;
            if (ballotStates[qs[slotCur][nodeIndex].validators[n]].curState == SCPPrepare) {
                if ((ballotStates[qs[slotCur][nodeIndex].validators[n]].p.counter != 0
                        &amp;&amp; (ballotStates[qs[slotCur][nodeIndex].validators[n]].p.value == candidate.value
                            &amp;&amp; ballotStates[qs[slotCur][nodeIndex].validators[n]].p.counter &gt;= candidate.counter))
                    || (ballotStates[qs[slotCur][nodeIndex].validators[n]].pp.counter != 0
                        &amp;&amp; (ballotStates[qs[slotCur][nodeIndex].validators[n]].pp.value == candidate.value
                            &amp;&amp; ballotStates[qs[slotCur][nodeIndex].validators[n]].pp.counter &gt;= candidate.counter))) {
                    if (qs[slotCur][nodeIndex].validators[n] != nodeIndex) {
                        cntQuorumTH++;
                        isVBlocked = true;
                    }
                }
                if (!isVBlocked
                    &amp;&amp; (ballotStates[qs[slotCur][nodeIndex].validators[n]].b.value == candidate.value
                        &amp;&amp; ballotStates[qs[slotCur][nodeIndex].validators[n]].b.counter &gt;= candidate.counter)) {
                    cntQuorumTH++;
                }
            }
            else if (ballotStates[qs[slotCur][nodeIndex].validators[n]].curState == SCPCommit) {
                if (ballotStates[qs[slotCur][nodeIndex].validators[n]].p.value == candidate.value
                    &amp;&amp; ballotStates[qs[slotCur][nodeIndex].validators[n]].p.counter &gt;= candidate.counter) {
                    if (qs[slotCur][nodeIndex].validators[n] != nodeIndex) {
                        cntQuorumTH++;
                        isVBlocked = true;
                    }
                }
                if (!isVBlocked
                    &amp;&amp; ballotStates[qs[slotCur][nodeIndex].validators[n]].b.value == candidate.value) {
                    cntQuorumTH++;
                }
            }
            else {// ballotStates[cur].curState == SCPExternalize
                if (ballotStates[qs[slotCur][nodeIndex].validators[n]].c.value == candidate.value) {
                    if (qs[slotCur][nodeIndex].validators[n] != nodeIndex) {
                        cntQuorumTH++;
                        isVBlocked = true;
                    }
                }
                if (!isVBlocked
                    &amp;&amp; ballotStates[qs[slotCur][nodeIndex].validators[n]].c.value == candidate.value) {
                    cntQuorumTH++;
                }
            }

            if (cntQuorumTH &gt;= qs[slotCur][nodeIndex].threshold) {
                return true;
            }
        }
    }

    return false;
}

bool checkAcceptedPrepare(const SCPBallot &amp;candidate) {
    int[0,N] cntVBlockTH = 0;
    int[0,N] cntQuorumTH = 0;

    if (ballotStates[nodeID].curState == SCPCommit) {
        if (!(ballotStates[nodeID].p.value == candidate.value
            &amp;&amp; ballotStates[nodeID].p.counter &lt; candidate.counter)) {
            return false;
        }
    }

    if (ballotStates[nodeID].pp.counter != 0
        &amp;&amp; (ballotStates[nodeID].pp.counter &gt; candidate.counter
            || (ballotStates[nodeID].pp.counter == candidate.counter
                &amp;&amp; !(isLessValue(ballotStates[nodeID].pp.value, candidate.value))))) { // ballotStates[nodeID].pp.value &gt;= candidate.value
        return false;
    }

    if (ballotStates[nodeID].p.counter != 0
        &amp;&amp; (ballotStates[nodeID].p.value == candidate.value
            &amp;&amp; ballotStates[nodeID].p.counter &gt;= candidate.counter)) {
        return false;
    }

    for (n : int[0,N-1]) {
        if (qs[slotCur][nodeID].validators[n] != N) {
            if (ballotStates[qs[slotCur][nodeID].validators[n]].curState == SCPPrepare) {
                if ((ballotStates[qs[slotCur][nodeID].validators[n]].p.counter != 0
                        &amp;&amp; (ballotStates[qs[slotCur][nodeID].validators[n]].p.value == candidate.value
                            &amp;&amp; ballotStates[qs[slotCur][nodeID].validators[n]].p.counter &gt;= candidate.counter))
                    || (ballotStates[qs[slotCur][nodeID].validators[n]].pp.counter != 0
                        &amp;&amp; (ballotStates[qs[slotCur][nodeID].validators[n]].pp.value == candidate.value
                            &amp;&amp; ballotStates[qs[slotCur][nodeID].validators[n]].pp.counter &gt;= candidate.counter))) {
                    if (qs[slotCur][nodeID].validators[n] != nodeID) {
                        cntVBlockTH++;
                    }
                }
            }
            else if (ballotStates[qs[slotCur][nodeID].validators[n]].curState == SCPCommit) {
                if (ballotStates[qs[slotCur][nodeID].validators[n]].p.value == candidate.value
                    &amp;&amp; ballotStates[qs[slotCur][nodeID].validators[n]].p.counter &gt;= candidate.counter) {
                    if (qs[slotCur][nodeID].validators[n] != nodeID) {
                        cntVBlockTH++;
                    }
                }
            }
            else {// ballotStates[qs[slotCur][nodeID].validators[n]].curState == SCPExternalize
                if (ballotStates[qs[slotCur][nodeID].validators[n]].c.value == candidate.value) {
                    if (qs[slotCur][nodeID].validators[n] != nodeID) {
                        cntVBlockTH++;
                    }
                }
            }

            if (cntVBlockTH &gt; totalValidators(nodeID) - qs[slotCur][nodeID].threshold) {
                return true;
            }

            if (checkAcceptedPrepareQuorum(n, candidate)) {
                cntQuorumTH++;
            }

            if (cntQuorumTH &gt;= qs[slotCur][nodeID].threshold) {
                return true;
            }
        }
    }

    return false;
}

bool attemptAcceptPrepare(SCPBallot &amp;acceptedBallot, SCPBallot &amp;newMessageBallots[3]) {
    bool isAgreed = false;
    bool hasNewAcceptedPrepare = false;
    SCPBallot tempBallot;

    for (n : int[0,N-1]) {
        if (qs[slotCur][nodeID].validators[n] != N) {
            isAgreed = false;
            tempBallot.counter = 0;
            tempBallot.value = NOVALUE;
            if (ballotStates[qs[slotCur][nodeID].validators[n]].curState == SCPPrepare) {
                for (j : int[0,2]) {
                    if (!isAgreed &amp;&amp; newMessageBallots[j].counter != 0) {
                        if (ballotStates[qs[slotCur][nodeID].validators[n]].b.value == newMessageBallots[j].value
                            &amp;&amp; ballotStates[qs[slotCur][nodeID].validators[n]].b.counter &lt;= newMessageBallots[j].counter) {
                            isAgreed = checkAcceptedPrepare(ballotStates[qs[slotCur][nodeID].validators[n]].b);
                            if (isAgreed) {
                                tempBallot.counter = ballotStates[qs[slotCur][nodeID].validators[n]].b.counter;
                                tempBallot.value = ballotStates[qs[slotCur][nodeID].validators[n]].b.value;
                            }
                            else {
                                if (ballotStates[qs[slotCur][nodeID].validators[n]].p.counter != 0
                                    &amp;&amp; (ballotStates[qs[slotCur][nodeID].validators[n]].p.value == newMessageBallots[j].value
                                        &amp;&amp; ballotStates[qs[slotCur][nodeID].validators[n]].p.counter &lt;= newMessageBallots[j].counter)) {
                                    isAgreed = checkAcceptedPrepare(ballotStates[qs[slotCur][nodeID].validators[n]].p);
                                    if (isAgreed) {
                                        tempBallot.counter = ballotStates[qs[slotCur][nodeID].validators[n]].p.counter;
                                        tempBallot.value = ballotStates[qs[slotCur][nodeID].validators[n]].p.value;
                                    }
                                    else {
                                        if (ballotStates[qs[slotCur][nodeID].validators[n]].pp.counter != 0
                                            &amp;&amp; (ballotStates[qs[slotCur][nodeID].validators[n]].pp.value == newMessageBallots[j].value
                                                &amp;&amp; ballotStates[qs[slotCur][nodeID].validators[n]].pp.counter &lt;= newMessageBallots[j].counter)) {
                                            isAgreed = checkAcceptedPrepare(ballotStates[qs[slotCur][nodeID].validators[n]].pp);
                                            if (isAgreed) {
                                                tempBallot.counter = ballotStates[qs[slotCur][nodeID].validators[n]].pp.counter;
                                                tempBallot.value = ballotStates[qs[slotCur][nodeID].validators[n]].pp.value;
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            else if (ballotStates[qs[slotCur][nodeID].validators[n]].curState == SCPCommit) {
                for (j : int[0,2]) {
                    if (!isAgreed &amp;&amp; newMessageBallots[j].counter != 0) {
                        if (ballotStates[qs[slotCur][nodeID].validators[n]].c.value == newMessageBallots[j].value) {
                            isAgreed = checkAcceptedPrepare(newMessageBallots[j]);
                            if (isAgreed) {
                                tempBallot.counter = newMessageBallots[j].counter;
                                tempBallot.value = newMessageBallots[j].value;
                            }
                            else {
                                if (ballotStates[qs[slotCur][nodeID].validators[n]].p.counter &lt; newMessageBallots[j].counter) {
                                    tempBallot.counter = ballotStates[qs[slotCur][nodeID].validators[n]].p.counter;
                                    tempBallot.value = newMessageBallots[j].value;
                                    isAgreed = checkAcceptedPrepare(tempBallot);
                                }
                            }
                        }
                    }
                }
            }
            else {// ballotStates[qs[slotCur][nodeID].validators[n]].curState == SCPExternalize
                for (j : int[0,2]) {
                    if (!isAgreed &amp;&amp; newMessageBallots[j].counter != 0) {
                        if (ballotStates[qs[slotCur][nodeID].validators[n]].c.value == newMessageBallots[j].value) {
                            isAgreed = checkAcceptedPrepare(newMessageBallots[j]);
                            if (isAgreed) {
                                tempBallot.counter = newMessageBallots[j].counter;
                                tempBallot.value = newMessageBallots[j].value;
                            }
                        }
                    }
                }
            }

            if (isAgreed) {
                hasNewAcceptedPrepare = true;
                if (acceptedBallot.counter &lt; tempBallot.counter
                    || (acceptedBallot.counter == tempBallot.counter
                        &amp;&amp; isLessValue(acceptedBallot.value, tempBallot.value))) { // acceptedBallot.value &lt; tempBallot.value
                    acceptedBallot.counter = tempBallot.counter;
                    acceptedBallot.value = tempBallot.value;
                }
            }
        }
    }

    return hasNewAcceptedPrepare;
}

bool checkConfirmedPrepareQuorum(int[0,N] nodeIndex, const SCPBallot &amp;candidate) {
    int[0,N] cntQuorumTH = 0;

    for (n : int[0,N-1]) {
        if (N - n + cntQuorumTH &lt; qs[slotCur][nodeIndex].threshold) {
            return false;
        }

        if (qs[slotCur][nodeIndex].validators[n] != N) {
            if (ballotStates[qs[slotCur][nodeIndex].validators[n]].curState == SCPPrepare) {
                if ((ballotStates[qs[slotCur][nodeIndex].validators[n]].p.counter != 0
                        &amp;&amp; (ballotStates[qs[slotCur][nodeIndex].validators[n]].p.value == candidate.value
                            &amp;&amp; ballotStates[qs[slotCur][nodeIndex].validators[n]].p.counter &gt;= candidate.counter))
                    || (ballotStates[qs[slotCur][nodeIndex].validators[n]].pp.counter != 0
                        &amp;&amp; (ballotStates[qs[slotCur][nodeIndex].validators[n]].pp.value == candidate.value
                            &amp;&amp; ballotStates[qs[slotCur][nodeIndex].validators[n]].pp.counter &gt;= candidate.counter))) {
                    cntQuorumTH++;
                }
            }
            else if (ballotStates[qs[slotCur][nodeIndex].validators[n]].curState == SCPCommit) {
                if (ballotStates[qs[slotCur][nodeIndex].validators[n]].p.value == candidate.value
                    &amp;&amp; ballotStates[qs[slotCur][nodeIndex].validators[n]].p.counter &gt;= candidate.counter) {
                    cntQuorumTH++;
                }
            }
            else {// ballotStates[qs[slotCur][nodeIndex].validators[n]].curState == SCPExternalize
                if (ballotStates[qs[slotCur][nodeIndex].validators[n]].c.value == candidate.value) {
                    cntQuorumTH++;
                }
            }

            if (cntQuorumTH &gt;= qs[slotCur][nodeIndex].threshold) {
                return true;
            }
        }
    }

    return false;
}

bool checkConfirmedPrepare(const SCPBallot &amp;candidate) {
    int[0,N] cntQuorumTH = 0;

    for (n : int[0,N-1]) {
        if (N - n + cntQuorumTH &lt; qs[slotCur][nodeID].threshold) {
            return false;
        }

        if (qs[slotCur][nodeID].validators[n] != N) {
            if (checkConfirmedPrepareQuorum(n, candidate)) {
                cntQuorumTH++;
            }

            if (cntQuorumTH &gt;= qs[slotCur][nodeID].threshold) {
                return true;
            }
        }
    }

    return false;
}

bool attemptConfirmPrepare(SCPBallot &amp;confirmedHBallot, SCPBallot &amp;newMessageBallots[3]) {
    bool isAgreed = false;
    bool hasNewConfirmedPrepare = false;
    SCPBallot tempBallot;

    for (n : int[0,N-1]) {
        if (qs[slotCur][nodeID].validators[n] != N) {
            isAgreed = false;
            tempBallot.counter = 0;
            tempBallot.value = NOVALUE;
            if (ballotStates[qs[slotCur][nodeID].validators[n]].curState == SCPPrepare) {
                for (j : int[0,2]) {
                    if (!isAgreed &amp;&amp; newMessageBallots[j].counter != 0) {
                        //if (ballotStates[qs[slotCur][nodeID].validators[n]].b.value == newMessageBallots[j].value
                        //    &amp;&amp; ballotStates[qs[slotCur][nodeID].validators[n]].b.counter &lt;= newMessageBallots[j].counter) {
                        //    isAgreed = checkConfirmedPrepare(ballotStates[qs[slotCur][nodeID].validators[n]].b);
                        //    if (isAgreed) {
                        //        tempBallot.counter = ballotStates[qs[slotCur][nodeID].validators[n]].b.counter;
                        //        tempBallot.value = ballotStates[qs[slotCur][nodeID].validators[n]].b.value;
                        //    }
                        //    else {
                                if (ballotStates[qs[slotCur][nodeID].validators[n]].p.counter != 0
                                    &amp;&amp; (ballotStates[qs[slotCur][nodeID].validators[n]].p.value == newMessageBallots[j].value
                                        &amp;&amp; ballotStates[qs[slotCur][nodeID].validators[n]].p.counter &lt;= newMessageBallots[j].counter)) {
                                    isAgreed = checkConfirmedPrepare(ballotStates[qs[slotCur][nodeID].validators[n]].p);
                                    if (isAgreed) {
                                        tempBallot.counter = ballotStates[qs[slotCur][nodeID].validators[n]].p.counter;
                                        tempBallot.value = ballotStates[qs[slotCur][nodeID].validators[n]].p.value;
                                    }
                                    else {
                                        if (ballotStates[qs[slotCur][nodeID].validators[n]].pp.counter != 0
                                            &amp;&amp; (ballotStates[qs[slotCur][nodeID].validators[n]].pp.value == newMessageBallots[j].value
                                                &amp;&amp; ballotStates[qs[slotCur][nodeID].validators[n]].pp.counter &lt;= newMessageBallots[j].counter)) {
                                            isAgreed = checkConfirmedPrepare(ballotStates[qs[slotCur][nodeID].validators[n]].pp);
                                            if (isAgreed) {
                                                tempBallot.counter = ballotStates[qs[slotCur][nodeID].validators[n]].pp.counter;
                                                tempBallot.value = ballotStates[qs[slotCur][nodeID].validators[n]].pp.value;
                                            }
                                        }
                                    }
                                }
                        //    }
                        //}
                    }
                }
            }
            else if (ballotStates[qs[slotCur][nodeID].validators[n]].curState == SCPCommit) {
                for (j : int[0,2]) {
                    if (!isAgreed &amp;&amp; newMessageBallots[j].counter != 0) {
                        //if (ballotStates[qs[slotCur][nodeID].validators[n]].c.value == newMessageBallots[j].value) {
                        //    isAgreed = checkConfirmedPrepare(newMessageBallots[j]);
                        //    if (isAgreed) {
                        //        tempBallot.counter = newMessageBallots[j].counter;
                        //        tempBallot.value = newMessageBallots[j].value;
                        //    }
                        //    else {
                                if (ballotStates[qs[slotCur][nodeID].validators[n]].p.counter &lt; newMessageBallots[j].counter) {
                                    tempBallot.counter = ballotStates[qs[slotCur][nodeID].validators[n]].p.counter;
                                    tempBallot.value = newMessageBallots[j].value;
                                    isAgreed = checkConfirmedPrepare(tempBallot);
                                }
                        //    }
                        //}
                    }
                }
            }
            else {// ballotStates[qs[slotCur][nodeID].validators[n]].curState == SCPExternalize
                for (j : int[0,2]) {
                    if (!isAgreed &amp;&amp; newMessageBallots[j].counter != 0) {
                        if (ballotStates[qs[slotCur][nodeID].validators[n]].c.value == newMessageBallots[j].value) {
                            isAgreed = checkConfirmedPrepare(newMessageBallots[j]);
                            if (isAgreed) {
                                tempBallot.counter = newMessageBallots[j].counter;
                                tempBallot.value = newMessageBallots[j].value;
                            }
                        }
                    }
                }
            }

            if (isAgreed) {
                if (ballotStates[nodeID].h.counter == 0
                    || (ballotStates[nodeID].h.counter &lt; tempBallot.counter
                        || (ballotStates[nodeID].h.counter == tempBallot.counter
                            &amp;&amp; isLessValue(ballotStates[nodeID].h.value, tempBallot.value)))) { // ballotStates[nodeID].h.value &lt; tempBallot.value
                    hasNewConfirmedPrepare = true;
                    if (confirmedHBallot.counter == 0) {
                        confirmedHBallot.counter = tempBallot.counter;
                        confirmedHBallot.value = tempBallot.value;
                    }
                    else {
                        if (confirmedHBallot.counter &lt; tempBallot.counter
                            || (confirmedHBallot.counter == tempBallot.counter
                                &amp;&amp; isLessValue(confirmedHBallot.value, tempBallot.value))) { // confirmedHBallot.value &lt; tempBallot.value
                            confirmedHBallot.counter = tempBallot.counter;
                            confirmedHBallot.value = tempBallot.value;
                        }
                    }
                }
            }
        }
    }

    return hasNewConfirmedPrepare;
}

void sortArr(int[0,N*3] len, int[0,INFINITY]&amp; arr[N*3]) {
    int[0,N*3] i,j,maxIndex;
    int[0,INFINITY] temp;

    for (i=0; i&lt;len; i++) {
        temp = arr[i];
        maxIndex = i;
        for (j=i+1; j&lt;len; j++) {
            if (temp &lt;= arr[j]) {
                temp = arr[j];
                maxIndex = j;
            }
        }
        arr[maxIndex] = arr[i];
        arr[i] = temp;
    }
}

bool checkAcceptedCommitQuorum(int[0,N] nodeIndex, const bool &amp;ballotValue[V], int[0,INFINITY] counterC, int[0,INFINITY] counterH) {
    int[0,N] cntQuorumTH = 0;
    bool isVBlocked = false;

    for (n : int[0,N-1]) {
        if (N - n + cntQuorumTH &lt; qs[slotCur][nodeIndex].threshold) {
            return false;
        }

        if (qs[slotCur][nodeIndex].validators[n] != N) {
            isVBlocked = false;
            if (ballotStates[qs[slotCur][nodeIndex].validators[n]].curState == SCPPrepare) {
                if (ballotStates[qs[slotCur][nodeIndex].validators[n]].b.value == ballotValue
                    &amp;&amp; ballotStates[qs[slotCur][nodeIndex].validators[n]].h.counter &gt;= counterH) {
                    cntQuorumTH++;
                }
            }
            else if (ballotStates[qs[slotCur][nodeIndex].validators[n]].curState == SCPCommit) {
                if (ballotStates[qs[slotCur][nodeIndex].validators[n]].b.value == ballotValue
                    &amp;&amp; (ballotStates[qs[slotCur][nodeIndex].validators[n]].c.counter &lt;= counterC
                        &amp;&amp; ballotStates[qs[slotCur][nodeIndex].validators[n]].h.counter &gt;= counterH)) {
                    cntQuorumTH++;
                    isVBlocked = true;
                }
                if (!isVBlocked
                    &amp;&amp; (ballotStates[qs[slotCur][nodeIndex].validators[n]].b.value == ballotValue
                        &amp;&amp; ballotStates[qs[slotCur][nodeIndex].validators[n]].c.counter &lt;= counterC)) {
                    cntQuorumTH++;
                }
            }
            else {// ballotStates[qs[slotCur][nodeIndex].validators[n]].curState == SCPExternalize
                if (ballotStates[qs[slotCur][nodeIndex].validators[n]].c.value == ballotValue
                    &amp;&amp; ballotStates[qs[slotCur][nodeIndex].validators[n]].c.counter &lt;= counterC) {
                    cntQuorumTH++;
                    isVBlocked = true;
                }
                if (!isVBlocked
                    &amp;&amp; (ballotStates[qs[slotCur][nodeIndex].validators[n]].c.value == ballotValue
                        &amp;&amp; ballotStates[qs[slotCur][nodeIndex].validators[n]].c.counter &lt;= counterC)) {
                    cntQuorumTH++;
                }
            }

            if (cntQuorumTH &gt;= qs[slotCur][nodeIndex].threshold) {
                return true;
            }
        }
    }

    return false;
}

bool checkAcceptedCommit(const bool &amp;ballotValue[V], int[0,INFINITY] counterC, int[0,INFINITY] counterH) {
    int[0,N] cntVBlockTH = 0;
    int[0,N] cntQuorumTH = 0;

    for (n : int[0,N-1]) {
        if (qs[slotCur][nodeID].validators[n] != N) {
            if (ballotStates[qs[slotCur][nodeID].validators[n]].curState == SCPPrepare) {
                // do nothing
            }
            else if (ballotStates[qs[slotCur][nodeID].validators[n]].curState == SCPCommit) {
                if (ballotStates[qs[slotCur][nodeID].validators[n]].b.value == ballotValue
                    &amp;&amp; (ballotStates[qs[slotCur][nodeID].validators[n]].c.counter &lt;= counterC
                        &amp;&amp; ballotStates[qs[slotCur][nodeID].validators[n]].h.counter &gt;= counterH)) {
                    cntVBlockTH++;
                }
            }
            else {// ballotStates[qs[slotCur][nodeID].validators[n]].curState == SCPExternalize
                if (ballotStates[qs[slotCur][nodeID].validators[n]].c.value == ballotValue
                    &amp;&amp; ballotStates[qs[slotCur][nodeID].validators[n]].c.counter &lt;= counterC) {
                    cntVBlockTH++;
                }
            }

            if (cntVBlockTH &gt; totalValidators(nodeID) - qs[slotCur][nodeID].threshold) {
                return true;
            }

            if (checkAcceptedCommitQuorum(n, ballotValue, counterC, counterH)) {
                cntQuorumTH++;
            }

            if (cntQuorumTH &gt;= qs[slotCur][nodeID].threshold) {
                return true;
            }
        }
    }

    return false;
}

bool attemptAcceptCommit(SCPBallot &amp;newMessageBallots[3], int[0,INFINITY] &amp;acceptedCounterC, int[0,INFINITY] &amp;acceptedCounterH) {
    int[0,N*3] k; // index for curBoundaries[N*3]
    int[0,INFINITY] curBoundaries[N*3];
    int[0,N*3] nextBoundary = 0;
    bool isAgreed = false;

    for (n : int[0,N-1]) {
        if (qs[slotCur][nodeID].validators[n] != N) {
            if (ballotStates[qs[slotCur][nodeID].validators[n]].curState == SCPPrepare
                &amp;&amp; ballotStates[qs[slotCur][nodeID].validators[n]].b.value == newMessageBallots[0].value) {
                if (ballotStates[qs[slotCur][nodeID].validators[n]].c.counter != 0) {
                    curBoundaries[nextBoundary++] = ballotStates[qs[slotCur][nodeID].validators[n]].c.counter;
                }
                if (ballotStates[qs[slotCur][nodeID].validators[n]].h.counter != 0) {
                    curBoundaries[nextBoundary++] = ballotStates[qs[slotCur][nodeID].validators[n]].h.counter;
                }
            }
            else if (ballotStates[qs[slotCur][nodeID].validators[n]].curState == SCPCommit
                &amp;&amp; ballotStates[qs[slotCur][nodeID].validators[n]].b.value == newMessageBallots[0].value) {
                curBoundaries[nextBoundary++] = ballotStates[qs[slotCur][nodeID].validators[n]].c.counter;
                curBoundaries[nextBoundary++] = ballotStates[qs[slotCur][nodeID].validators[n]].h.counter;
            }
            else {// ballotStates[qs[slotCur][nodeID].validators[n]].curState == SCPExternalize
                if (ballotStates[qs[slotCur][nodeID].validators[n]].c.value == newMessageBallots[0].value) {
                    curBoundaries[nextBoundary++] = ballotStates[qs[slotCur][nodeID].validators[n]].c.counter;
                    curBoundaries[nextBoundary++] = ballotStates[qs[slotCur][nodeID].validators[n]].h.counter;
                    curBoundaries[nextBoundary++] = INFINITY;
                }
            }
        }
    }

    // sort curBoundaries[0 .. nextBoundary-1]: highest first
    sortArr(nextBoundary, curBoundaries);

    k = 0;
    acceptedCounterC = 0;
    acceptedCounterH = 0;
    isAgreed = false;
    do {
        if (acceptedCounterH == 0) {// find the high boundary
            if (checkAcceptedCommit(newMessageBallots[0].value, curBoundaries[k], curBoundaries[k])) {
                isAgreed = true;
                acceptedCounterH = curBoundaries[k];
                k++;
            }
            else {
                k++;
            }
        }
        else {// find the low boundary
            if (checkAcceptedCommit(newMessageBallots[0].value, curBoundaries[k], acceptedCounterH)) {
                acceptedCounterC = curBoundaries[k];
                k = nextBoundary;
            }
            else {
                k++;
            }
        }
    } while (acceptedCounterC == 0 &amp;&amp; k &lt; nextBoundary);

    return isAgreed;
}

bool checkConfirmedCommitQuorum(int[0,N] nodeIndex, const bool &amp;ballotValue[V], int[0,INFINITY] counterC, int[0,INFINITY] counterH) {
    int[0,N] cntQuorumTH = 0;

    for (n : int[0,N-1]) {
        if (N - n + cntQuorumTH &lt; qs[slotCur][nodeIndex].threshold) {
            return false;
        }

        if (qs[slotCur][nodeIndex].validators[n] != N) {
            if (ballotStates[qs[slotCur][nodeIndex].validators[n]].curState == SCPPrepare) {
                // do nothing
            }
            else if (ballotStates[qs[slotCur][nodeIndex].validators[n]].curState == SCPCommit) {
                if (ballotStates[qs[slotCur][nodeIndex].validators[n]].b.value == ballotValue
                    &amp;&amp; ballotStates[qs[slotCur][nodeIndex].validators[n]].c.counter &lt;= counterC
                    &amp;&amp; ballotStates[qs[slotCur][nodeIndex].validators[n]].h.counter &gt;= counterH) {
                    cntQuorumTH++;
                }
            }
            else {// ballotStates[qs[slotCur][nodeIndex].validators[n]].curState == SCPExternalize
                if (ballotStates[qs[slotCur][nodeIndex].validators[n]].c.value == ballotValue
                    &amp;&amp; ballotStates[qs[slotCur][nodeIndex].validators[n]].c.counter &lt;= counterC) {
                    cntQuorumTH++;
                }
            }

            if (cntQuorumTH &gt;= qs[slotCur][nodeIndex].threshold) {
                return true;
            }
        }
    }

    return false;
}

bool checkConfirmedCommit(const bool &amp;ballotValue[V], int[0,INFINITY] counterC, int[0,INFINITY] counterH) {
    int[0,N] cntQuorumTH = 0;

    for (n : int[0,N-1]) {
        if (qs[slotCur][nodeID].validators[n] != N) {
            if (N - n + cntQuorumTH &lt; qs[slotCur][nodeID].threshold) {
                return false;
            }

            if (checkConfirmedCommitQuorum(n, ballotValue, counterC, counterH)) {
                cntQuorumTH++;
            }

            if (cntQuorumTH &gt;= qs[slotCur][nodeID].threshold) {
                return true;
            }
        }
    }

    return false;
}

bool attemptConfirmCommit(SCPBallot &amp;newMessageBallots[3], int[0,INFINITY] &amp;acceptedCounterC, int[0,INFINITY] &amp;acceptedCounterH) {
    int[0,N*3] k; // index for curBoundaries[N*3]
    int[0,INFINITY] curBoundaries[N*3];
    int[0,N*3] nextBoundary = 0;
    bool isAgreed = false;

    for (n : int[0,N-1]) {
        if (qs[slotCur][nodeID].validators[n] != N) {
            if (ballotStates[qs[slotCur][nodeID].validators[n]].curState == SCPPrepare) {
                // do nothing
            }
            else if (ballotStates[qs[slotCur][nodeID].validators[n]].curState == SCPCommit
                &amp;&amp; ballotStates[qs[slotCur][nodeID].validators[n]].b.value == newMessageBallots[0].value) {
                curBoundaries[nextBoundary++] = ballotStates[qs[slotCur][nodeID].validators[n]].c.counter;
                curBoundaries[nextBoundary++] = ballotStates[qs[slotCur][nodeID].validators[n]].h.counter;
            }
            else {// ballotStates[qs[slotCur][nodeID].validators[n]].curState == SCPExternalize
                if (ballotStates[qs[slotCur][nodeID].validators[n]].c.value == newMessageBallots[0].value) {
                    curBoundaries[nextBoundary++] = ballotStates[qs[slotCur][nodeID].validators[n]].c.counter;
                    curBoundaries[nextBoundary++] = ballotStates[qs[slotCur][nodeID].validators[n]].h.counter;
                    curBoundaries[nextBoundary++] = INFINITY;
                }
            }
        }
    }

    // sort curBoundaries[0 .. nextBoundary-1]: highest first
    sortArr(nextBoundary, curBoundaries);

    k = 0;
    acceptedCounterC = 0;
    acceptedCounterH = 0;
    isAgreed = false;
    do {
        if (acceptedCounterH == 0) {// find the high boundary
            if (checkConfirmedCommit(newMessageBallots[0].value, curBoundaries[k], curBoundaries[k])) {
                isAgreed = true;
                acceptedCounterH = curBoundaries[k];
                k++;
            }
            else {
                k++;
            }
        }
        else {// find the low boundary
            if (checkConfirmedCommit(newMessageBallots[0].value, curBoundaries[k], acceptedCounterH)) {
                acceptedCounterC = curBoundaries[k];
                k = nextBoundary;
            }
            else {
                k++;
            }
        }
    } while (acceptedCounterC == 0 &amp;&amp; k &lt; nextBoundary);

    return isAgreed;
}

void processMessagePrepare() {
    bool hasNewBallot = false;
    int[0,N-1] newMessageNode = nodeID;
    int[0,N-1] newMessageNodeIndex = 0;
    int[0,N] current = 0;
    int[0,INFINITY] acceptedCounterC = 0;
    int[0,INFINITY] acceptedCounterH = 0;
    SCPBallot newBallot;
    SCPBallot newMessageBallots[3];

    //if (ballotStates[nodeID].b.counter == INFINITY) {
    //    for (n : int[0,N-1]) {
    //        if (qs[slotCur][nodeID].validators[n] != N &amp;&amp; qs[slotCur][nodeID].validators[n] != nodeID) {
    //            if (ballotStates[qs[slotCur][nodeID].validators[n]].b.counter &gt;= ballotStates[nodeID].b.counter) {
    //                newMessageNode = qs[slotCur][nodeID].validators[n];
    //            }
    //        }
    //    }
    //    if (newMessageNode == nodeID) {
    //        return;
    //    }
    //}
    //else {
    //    newMessageNode = ballotStates[nodeID].b.counter % N;
    //    if (qs[slotCur][nodeID].validators[newMessageNode] == N || newMessageNode == nodeID) {
    //        return;
    //    }
    //    if (ballotStates[qs[slotCur][nodeID].validators[newMessageNode]].b.counter &lt; ballotStates[nodeID].b.counter) {
    //        return;
    //    }
    //}

    //for (n : int[0,N-1]) {
    //    if (qs[slotCur][nodeID].validators[n] != N &amp;&amp; qs[slotCur][nodeID].validators[n] != nodeID) {
    //        if (ballotStates[qs[slotCur][nodeID].validators[n]].b.counter &gt;= ballotStates[nodeID].b.counter) {
    //           if (newMessageNode == nodeID) {
    //                newMessageNode = qs[slotCur][nodeID].validators[n];
    //            }
    //            else {
    //                if (ballotStates[qs[slotCur][nodeID].validators[n]].b.counter &gt;= ballotStates[newMessageNode].b.counter) {
    //                    newMessageNode = qs[slotCur][nodeID].validators[n];
    //                }
    //            }
    //        }
    //    }
    //}
    //if (newMessageNode == nodeID) {
    //    return;
    //}

    //newMessageNode = cur_b_cnt[nodeID] % N;
    //if (qs[slotCur][nodeID].validators[newMessageNode] == N) {// || newMessageNode == nodeID) {
    //    return;
    //}
    newMessageNodeIndex = cur_b_cnt[nodeID] % totalValidators(nodeID);
    for (n : n_id) {
        if (qs[slotCur][nodeID].validators[n] != N) {
            if (current == newMessageNodeIndex) {
                newMessageNode = qs[slotCur][nodeID].validators[n];
            }
            else {
                current++;
            }
        }
    }
    if (ballotStates[qs[slotCur][nodeID].validators[newMessageNode]].b.counter &lt; ballotStates[nodeID].b.counter) {
        return;
    }

    if (ballotStates[newMessageNode].curState == SCPPrepare) {
        newMessageBallots[0].counter = ballotStates[newMessageNode].b.counter;
        newMessageBallots[0].value = ballotStates[newMessageNode].b.value;
        newMessageBallots[1].counter = ballotStates[newMessageNode].p.counter;
        newMessageBallots[1].value = ballotStates[newMessageNode].p.value;
        newMessageBallots[2].counter = ballotStates[newMessageNode].pp.counter;
        newMessageBallots[2].value = ballotStates[newMessageNode].pp.value;
    }
    else if (ballotStates[newMessageNode].curState == SCPCommit) {
        newMessageBallots[0].counter = ballotStates[newMessageNode].p.counter;
        newMessageBallots[0].value = ballotStates[newMessageNode].b.value;
        newMessageBallots[1].counter = INFINITY;
        newMessageBallots[1].value = ballotStates[newMessageNode].b.value;
        newMessageBallots[2].counter = 0;
        newMessageBallots[2].value = NOVALUE;
    }
    else {// ballotStates[newMessageNode].curState == SCPExternalize
        newMessageBallots[0].counter = INFINITY;
        newMessageBallots[0].value = ballotStates[newMessageNode].c.value;
        newMessageBallots[1].counter = 0;
        newMessageBallots[1].value = NOVALUE;
        newMessageBallots[2].counter = 0;
        newMessageBallots[2].value = NOVALUE;
    }

    // blocking threshold check for b.counter

    // blocking threshold check for accept prepare ballots (attemptAcceptPrepare)
    // quorum threshold check for vote prepare ballots (attemptAcceptPrepare)
    newBallot.counter = 0;
    newBallot.value = NOVALUE;
    hasNewBallot = attemptAcceptPrepare(newBallot, newMessageBallots);

    if (hasNewBallot) {
        // update p or pp
        if (ballotStates[nodeID].p.counter == 0) {
            ballotStates[nodeID].p.counter = newBallot.counter;
            ballotStates[nodeID].p.value = newBallot.value;
        }
        else {
            if (ballotStates[nodeID].p.counter &lt; newBallot.counter
                || (ballotStates[nodeID].p.counter == newBallot.counter
                    &amp;&amp; isLessValue(ballotStates[nodeID].p.value, newBallot.value))) { // ballotStates[nodeID].p.value &lt; newBallot.value
                if (ballotStates[nodeID].p.value != newBallot.value) {
                    ballotStates[nodeID].pp.counter = ballotStates[nodeID].p.counter;
                    ballotStates[nodeID].pp.value = ballotStates[nodeID].p.value;
                }
                ballotStates[nodeID].p.counter = newBallot.counter;
                ballotStates[nodeID].p.value = newBallot.value;
            }
            else if (ballotStates[nodeID].p.counter &gt; newBallot.counter
                || (ballotStates[nodeID].p.counter == newBallot.counter
                    &amp;&amp; isLessValue(newBallot.value, ballotStates[nodeID].p.value))) { // ballotStates[nodeID].p.value &gt; newBallot.value
                if (ballotStates[nodeID].pp.counter == 0
                    || (ballotStates[nodeID].pp.counter &lt; newBallot.counter
                        || (ballotStates[nodeID].pp.counter == newBallot.counter
                            &amp;&amp; isLessValue(ballotStates[nodeID].pp.value, newBallot.value)))) { // ballotStates[nodeID].pp.value &lt; newBallot.value
                    if (ballotStates[nodeID].p.value != newBallot.value) {
                        ballotStates[nodeID].pp.counter = newBallot.counter;
                        ballotStates[nodeID].pp.value = newBallot.value;
                    }
                }
            }
        }

        // clare c if required
        if (ballotStates[nodeID].c.counter != 0
            &amp;&amp; ballotStates[nodeID].h.counter != 0
            &amp;&amp; ((ballotStates[nodeID].p.counter != 0
                    &amp;&amp; ballotStates[nodeID].h.value != ballotStates[nodeID].p.value
                    &amp;&amp; ballotStates[nodeID].h.counter &lt; ballotStates[nodeID].p.counter)
                || (ballotStates[nodeID].pp.counter != 0
                    &amp;&amp; ballotStates[nodeID].h.value != ballotStates[nodeID].pp.value
                    &amp;&amp; ballotStates[nodeID].h.counter &lt; ballotStates[nodeID].pp.counter))) {
            ballotStates[nodeID].c.counter = 0;
            ballotStates[nodeID].c.value = NOVALUE;
        }
    }

    // quorum threshold check for accept prepare ballots (attemptConfirmPrepare)
    if (ballotStates[nodeID].p.counter != 0) {
        newBallot.counter = 0;
        newBallot.value = NOVALUE;
        hasNewBallot = attemptConfirmPrepare(newBallot, newMessageBallots);

        if (hasNewBallot) {
            // update h or c
            if (newBallot.counter != 0) {
                ballotStates[nodeID].h.counter = newBallot.counter;
                ballotStates[nodeID].h.value = newBallot.value;
                if (ballotStates[nodeID].c.counter == 0
                    &amp;&amp; (ballotStates[nodeID].p.counter == 0
                        || !(ballotStates[nodeID].p.value != newBallot.value
                            &amp;&amp; ballotStates[nodeID].p.counter &lt;= newBallot.counter))
                    &amp;&amp; (ballotStates[nodeID].pp.counter == 0
                        || !(ballotStates[nodeID].pp.value != newBallot.value
                            &amp;&amp; ballotStates[nodeID].pp.counter &lt;= newBallot.counter))
                    &amp;&amp; (ballotStates[nodeID].b.counter &lt; newBallot.counter
                        || (ballotStates[nodeID].b.counter == newBallot.counter
                            &amp;&amp; !isLessValue(newBallot.value, ballotStates[nodeID].b.value)))) { // ballotStates[nodeID].b.value &lt;= newBallot.value
                    ballotStates[nodeID].c.counter = newBallot.counter;
                    ballotStates[nodeID].c.value = newBallot.value;
                }
            }

            // bump b if required
            if (ballotStates[nodeID].b.counter == 0
                || (ballotStates[nodeID].b.counter &lt; ballotStates[nodeID].h.counter
                    || (ballotStates[nodeID].b.counter == ballotStates[nodeID].h.counter
                        &amp;&amp; isLessValue(ballotStates[nodeID].b.value, ballotStates[nodeID].h.value)))) { // ballotStates[nodeID].b.value &lt; ballotStates[nodeID].h.value
                ballotStates[nodeID].b.counter = ballotStates[nodeID].h.counter;
                ballotStates[nodeID].b.value = ballotStates[nodeID].h.value;
            }
        }
    }

    // blocking threshold check for accept commit ballots (attemptAcceptCommit)
    // quorum threshold check for vote commit ballots (attemptAcceptCommit)
    if (ballotStates[newMessageNode].h.counter != 0) {
        newMessageBallots[0].counter = ballotStates[newMessageNode].h.counter;
        if (ballotStates[newMessageNode].curState == SCPExternalize) {
            newMessageBallots[0].value = ballotStates[newMessageNode].c.value;
        }
        else {
            newMessageBallots[0].value = ballotStates[newMessageNode].b.value;
        }

        hasNewBallot = attemptAcceptCommit(newMessageBallots, acceptedCounterC, acceptedCounterH);

        if (hasNewBallot) {
            if (acceptedCounterC == 0) {
                acceptedCounterC = acceptedCounterH;
            }

            ballotStates[nodeID].c.counter = acceptedCounterC;
            ballotStates[nodeID].c.value = newMessageBallots[0].value;
            ballotStates[nodeID].h.counter = acceptedCounterH;
            ballotStates[nodeID].h.value = newMessageBallots[0].value;
            ballotStates[nodeID].curState = SCPCommit;
            ballotStates[nodeID].pp.counter = 0;
            ballotStates[nodeID].pp.value = NOVALUE;

            canTick[nodeID] = false;
        }
    }

    if (ballotStates[nodeID].h.counter &gt; ballotStates[nodeID].b.counter) {
        ballotStates[nodeID].b.counter = ballotStates[nodeID].h.counter;
        ballotStates[nodeID].b.value = ballotStates[nodeID].h.value;
    }
}

void processMessageCommit() {
    bool hasNewBallot = false;
    int[0,N-1] newMessageNode = nodeID;
    int[0,N-1] newMessageNodeIndex = 0;
    int[0,N] current = 0;
    int[0,INFINITY] acceptedCounterC = 0;
    int[0,INFINITY] acceptedCounterH = 0;
    SCPBallot newBallot;
    SCPBallot newMessageBallots[3];

    //if (ballotStates[nodeID].b.counter == INFINITY) {
    //    for (n : int[0,N-1]) {
    //        if (qs[slotCur][nodeID].validators[n] != N &amp;&amp; qs[slotCur][nodeID].validators[n] != nodeID) {
    //            if (ballotStates[qs[slotCur][nodeID].validators[n]].b.counter &gt;= ballotStates[nodeID].b.counter) {
    //                newMessageNode = qs[slotCur][nodeID].validators[n];
    //            }
    //        }
    //    }
    //    if (newMessageNode == nodeID) {
    //        return;
    //    }
    //}
    //else {
    //    newMessageNode = ballotStates[nodeID].b.counter % N;
    //    if (qs[slotCur][nodeID].validators[newMessageNode] == N || newMessageNode == nodeID) {
    //        return;
    //    }
    //    if (ballotStates[qs[slotCur][nodeID].validators[newMessageNode]].b.counter &lt; ballotStates[nodeID].b.counter) {
    //        return;
    //    }
    //}

    //for (n : int[0,N-1]) {
    //    if (qs[slotCur][nodeID].validators[n] != N &amp;&amp; qs[slotCur][nodeID].validators[n] != nodeID) {
    //        if (ballotStates[qs[slotCur][nodeID].validators[n]].b.counter &gt;= ballotStates[nodeID].b.counter) {
    //           if (newMessageNode == nodeID) {
    //                newMessageNode = qs[slotCur][nodeID].validators[n];
    //            }
    //            else {
    //                if (ballotStates[qs[slotCur][nodeID].validators[n]].b.counter &gt;= ballotStates[newMessageNode].b.counter) {
    //                    newMessageNode = qs[slotCur][nodeID].validators[n];
    //                }
    //            }
    //        }
    //    }
    //}
    //if (newMessageNode == nodeID) {
    //    return;
    //}

    //newMessageNode = cur_b_cnt[nodeID] % N;
    //if (qs[slotCur][nodeID].validators[newMessageNode] == N) {// || newMessageNode == nodeID) {
    //    return;
    //}
    newMessageNodeIndex = cur_b_cnt[nodeID] % totalValidators(nodeID);
    for (n : n_id) {
        if (qs[slotCur][nodeID].validators[n] != N) {
            if (current == newMessageNodeIndex) {
                newMessageNode = qs[slotCur][nodeID].validators[n];
            }
            else {
                current++;
            }
        }
    }
    if (ballotStates[qs[slotCur][nodeID].validators[newMessageNode]].b.counter &lt; ballotStates[nodeID].b.counter) {
        return;
    }

    if (ballotStates[newMessageNode].curState == SCPPrepare) {
        newMessageBallots[0].counter = ballotStates[newMessageNode].b.counter;
        newMessageBallots[0].value = ballotStates[newMessageNode].b.value;
        newMessageBallots[1].counter = ballotStates[newMessageNode].p.counter;
        newMessageBallots[1].value = ballotStates[newMessageNode].p.value;
        newMessageBallots[2].counter = ballotStates[newMessageNode].pp.counter;
        newMessageBallots[2].value = ballotStates[newMessageNode].pp.value;
    }
    else if (ballotStates[newMessageNode].curState == SCPCommit) {
        newMessageBallots[0].counter = ballotStates[newMessageNode].p.counter;
        newMessageBallots[0].value = ballotStates[newMessageNode].b.value;
        newMessageBallots[1].counter = INFINITY;
        newMessageBallots[1].value = ballotStates[newMessageNode].b.value;
        newMessageBallots[2].counter = 0;
        newMessageBallots[2].value = NOVALUE;
    }
    else {// ballotStates[newMessageNode].curState == SCPExternalize
        newMessageBallots[0].counter = INFINITY;
        newMessageBallots[0].value = ballotStates[newMessageNode].c.value;
        newMessageBallots[1].counter = 0;
        newMessageBallots[1].value = NOVALUE;
        newMessageBallots[2].counter = 0;
        newMessageBallots[2].value = NOVALUE;
    }

    // blocking threshold check for b.counter

    // blocking threshold check for accept prepare ballots (attemptAcceptPrepare)
    // quorum threshold check for vote prepare ballots (attemptAcceptPrepare)
    newBallot.counter = 0;
    newBallot.value = NOVALUE;
    hasNewBallot = attemptAcceptPrepare(newBallot, newMessageBallots);

    if (hasNewBallot) {
        // update p or pp
        if (ballotStates[nodeID].p.counter == 0) {
            ballotStates[nodeID].p.counter = newBallot.counter;
            ballotStates[nodeID].p.value = newBallot.value;
        }
        else {
            if (ballotStates[nodeID].p.counter &lt; newBallot.counter
                || (ballotStates[nodeID].p.counter == newBallot.counter
                    &amp;&amp; isLessValue(ballotStates[nodeID].p.value, newBallot.value))) { // ballotStates[nodeID].p.value &lt; newBallot.value
                if (ballotStates[nodeID].p.value != newBallot.value) {
                    ballotStates[nodeID].pp.counter = ballotStates[nodeID].p.counter;
                    ballotStates[nodeID].pp.value = ballotStates[nodeID].p.value;
                }
                ballotStates[nodeID].p.counter = newBallot.counter;
                ballotStates[nodeID].p.value = newBallot.value;
            }
            else if (ballotStates[nodeID].p.counter &gt; newBallot.counter
                || (ballotStates[nodeID].p.counter == newBallot.counter
                    &amp;&amp; isLessValue(newBallot.value, ballotStates[nodeID].p.value))) { // ballotStates[nodeID].p.value &gt; newBallot.value
                if (ballotStates[nodeID].pp.counter == 0
                    || (ballotStates[nodeID].pp.counter &lt; newBallot.counter
                        || (ballotStates[nodeID].pp.counter == newBallot.counter
                            &amp;&amp; isLessValue(ballotStates[nodeID].pp.value, newBallot.value)))) { // ballotStates[nodeID].pp.value &lt; newBallot.value
                    if (ballotStates[nodeID].p.value != newBallot.value) {
                        ballotStates[nodeID].pp.counter = newBallot.counter;
                        ballotStates[nodeID].pp.value = newBallot.value;
                    }
                }
            }
        }
    }

    // blocking threshold check for accept commit ballots (attemptAcceptCommit)
    // quorum threshold check for vote commit ballots (attemptAcceptCommit)
    if (ballotStates[newMessageNode].h.counter != 0) {
        newMessageBallots[0].counter = ballotStates[newMessageNode].h.counter;
        if (ballotStates[newMessageNode].curState == SCPExternalize) {
            newMessageBallots[0].value = ballotStates[newMessageNode].c.value;
        }
        else {
            newMessageBallots[0].value = ballotStates[newMessageNode].b.value;
        }

        hasNewBallot = attemptAcceptCommit(newMessageBallots, acceptedCounterC, acceptedCounterH);

        if (hasNewBallot) {
            if (acceptedCounterC == 0) {
                acceptedCounterC = acceptedCounterH;
            }

            ballotStates[nodeID].c.counter = acceptedCounterC;
            ballotStates[nodeID].c.value = newMessageBallots[0].value;
            ballotStates[nodeID].h.counter = acceptedCounterH;
            ballotStates[nodeID].h.value = newMessageBallots[0].value;
            ballotStates[nodeID].pp.counter = 0;
            ballotStates[nodeID].pp.value = NOVALUE;
        }
    }

    // quorum threshold check for accept commit ballots (attemptConfirmCommit)
    if (ballotStates[newMessageNode].curState != SCPPrepare) {
        newMessageBallots[0].counter = ballotStates[newMessageNode].h.counter;
        if (ballotStates[newMessageNode].curState == SCPExternalize) {
            newMessageBallots[0].value = ballotStates[newMessageNode].c.value;
        }
        else {
            newMessageBallots[0].value = ballotStates[newMessageNode].b.value;
        }

        hasNewBallot = attemptConfirmCommit(newMessageBallots, acceptedCounterC, acceptedCounterH);

        if (hasNewBallot) {
            if (acceptedCounterC == 0) {
                acceptedCounterC = acceptedCounterH;
            }

            ballotStates[nodeID].c.counter = acceptedCounterC;
            ballotStates[nodeID].c.value = newMessageBallots[0].value;
            ballotStates[nodeID].h.counter = acceptedCounterH;
            ballotStates[nodeID].h.value = newMessageBallots[0].value;
            ballotStates[nodeID].curState = SCPExternalize;
            ballotStates[nodeID].b.counter = INFINITY;

            canTick[nodeID] = false;
        }
    }

    if (ballotStates[nodeID].h.counter &gt; ballotStates[nodeID].b.counter) {
        ballotStates[nodeID].b.counter = ballotStates[nodeID].h.counter;
        ballotStates[nodeID].b.value = ballotStates[nodeID].h.value;
    }
}

void newBCounter() {
    if (tickBallot[nodeID] == cur_b_cnt[nodeID]) {
        if (ballotStates[nodeID].curState == SCPPrepare) {
            processMessagePrepare();

            if (ballotStates[nodeID].b.counter&lt;MAXCNT) {
                ballotStates[nodeID].b.counter++;
            }
            if (cur_b_cnt[nodeID] &lt; MAXCNT) {
                cur_b_cnt[nodeID]++;
            }
            updatebValue();
        }
        else if (ballotStates[nodeID].curState == SCPCommit) {
            processMessageCommit();

            if (ballotStates[nodeID].b.counter&lt;MAXCNT) {
                ballotStates[nodeID].b.counter++;
            }
            if (cur_b_cnt[nodeID] &lt; MAXCNT) {
                cur_b_cnt[nodeID]++;
            }
            updatebValue();
        }
        else {// ballotStates[nodeID].curState == SCPExternalize
            // do nothing
        }

        tickBallot[nodeID] = 0;
    }

    if (tickBallot[nodeID] &lt; cur_b_cnt[nodeID]) {
        tickBallot[nodeID]++;
    }

    //n_clockBCounter = 0;
}
</declaration>
		<location id="id24" x="263" y="-17">
			<name x="170" y="-17">Externalize</name>
		</location>
		<location id="id25" x="-102" y="-17">
			<name x="-178" y="-17">Commit</name>
		</location>
		<location id="id26" x="-484" y="-17">
			<name x="-561" y="-8">Prepare</name>
		</location>
		<location id="id27" x="-705" y="-17">
			<name x="-688" y="-42">StartBallot</name>
		</location>
		<location id="id28" x="263" y="136">
			<committed/>
		</location>
		<location id="id29" x="-595" y="-17">
			<committed/>
		</location>
		<location id="id30" x="-229" y="-17">
			<committed/>
		</location>
		<location id="id31" x="144" y="-17">
			<committed/>
		</location>
		<location id="id32" x="-484" y="136">
			<committed/>
		</location>
		<location id="id33" x="-102" y="136">
			<committed/>
		</location>
		<location id="id34" x="-357" y="-17">
			<committed/>
		</location>
		<location id="id35" x="17" y="-17">
			<committed/>
		</location>
		<init ref="id27"/>
		<transition>
			<source ref="id35"/>
			<target ref="id31"/>
			<label kind="synchronisation" x="-51" y="-8">tickAdvanceDone[nodeID]!</label>
			<label kind="assignment" x="-51" y="8">ballotDone[nodeID] = true, cur_b_cnt[nodeID] = INFINITY</label>
		</transition>
		<transition>
			<source ref="id25"/>
			<target ref="id35"/>
			<label kind="guard" x="-93" y="-85">ballotStates[nodeID].curState == SCPExternalize</label>
			<label kind="synchronisation" x="-93" y="-68">tickAdvance[nodeID]?</label>
		</transition>
		<transition>
			<source ref="id34"/>
			<target ref="id30"/>
			<label kind="synchronisation" x="-391" y="0">tickAdvanceDone[nodeID]!</label>
			<label kind="assignment" x="-391" y="17">cur_round[nodeID] = INFINITY</label>
		</transition>
		<transition>
			<source ref="id26"/>
			<target ref="id34"/>
			<label kind="guard" x="-476" y="-85">ballotStates[nodeID].curState == SCPCommit</label>
			<label kind="synchronisation" x="-476" y="-68">tickAdvanceBallot[nodeID]?</label>
		</transition>
		<transition>
			<source ref="id33"/>
			<target ref="id25"/>
			<label kind="synchronisation" x="-110" y="102">tickAdvanceDone[nodeID]!</label>
			<nail x="-25" y="59"/>
		</transition>
		<transition>
			<source ref="id25"/>
			<target ref="id33"/>
			<label kind="guard" x="-365" y="34">ballotStates[nodeID].curState == SCPCommit</label>
			<label kind="synchronisation" x="-365" y="51">tickAdvance[nodeID]?</label>
			<label kind="assignment" x="-365" y="68">newBCounter()</label>
			<nail x="-178" y="59"/>
		</transition>
		<transition>
			<source ref="id32"/>
			<target ref="id26"/>
			<label kind="synchronisation" x="-493" y="102">tickAdvanceDone[nodeID]!</label>
			<nail x="-408" y="59"/>
		</transition>
		<transition>
			<source ref="id26"/>
			<target ref="id32"/>
			<label kind="guard" x="-722" y="34">ballotStates[nodeID].curState == SCPPrepare</label>
			<label kind="synchronisation" x="-722" y="51">tickAdvanceBallot[nodeID]?</label>
			<label kind="assignment" x="-722" y="68">newBCounter()</label>
			<nail x="-561" y="59"/>
		</transition>
		<transition>
			<source ref="id31"/>
			<target ref="id24"/>
			<label kind="synchronisation" x="161" y="-34">slotDone!</label>
		</transition>
		<transition>
			<source ref="id30"/>
			<target ref="id25"/>
			<label kind="synchronisation" x="-289" y="-51">nominationDone[nodeID]!</label>
		</transition>
		<transition>
			<source ref="id29"/>
			<target ref="id26"/>
			<label kind="synchronisation" x="-680" y="-59">tickAdvanceDone[nodeID]!</label>
		</transition>
		<transition>
			<source ref="id27"/>
			<target ref="id29"/>
			<label kind="synchronisation" x="-765" y="0">sthNominated[nodeID]?</label>
			<label kind="assignment" x="-765" y="17">initBallotState()</label>
		</transition>
		<transition>
			<source ref="id28"/>
			<target ref="id24"/>
			<label kind="synchronisation" x="161" y="102">tickAdvanceDone[nodeID]!</label>
			<nail x="340" y="59"/>
		</transition>
		<transition>
			<source ref="id24"/>
			<target ref="id28"/>
			<label kind="guard" x="0" y="34">ballotStates[nodeID].curState == SCPExternalize</label>
			<label kind="synchronisation" x="0" y="51">tickAdvance[nodeID]?</label>
			<nail x="187" y="59"/>
		</transition>
		<transition>
			<source ref="id24"/>
			<target ref="id27"/>
			<label kind="synchronisation" x="-76" y="-195">slotTimeout?</label>
			<label kind="assignment" x="-76" y="-178">resetBallotState()</label>
			<nail x="263" y="-161"/>
			<nail x="-705" y="-161"/>
		</transition>
		<transition>
			<source ref="id24"/>
			<target ref="id27"/>
			<label kind="synchronisation" x="-76" y="-127">slotFail?</label>
			<label kind="assignment" x="-76" y="-110">resetBallotState()</label>
			<nail x="263" y="-93"/>
			<nail x="-706" y="-93"/>
		</transition>
		<transition>
			<source ref="id25"/>
			<target ref="id27"/>
			<label kind="synchronisation" x="-459" y="-195">slotTimeout?</label>
			<label kind="assignment" x="-459" y="-178">resetBallotState()</label>
			<nail x="-102" y="-161"/>
			<nail x="-705" y="-161"/>
		</transition>
		<transition>
			<source ref="id25"/>
			<target ref="id27"/>
			<label kind="synchronisation" x="-459" y="-127">slotFail?</label>
			<label kind="assignment" x="-459" y="-110">resetBallotState()</label>
			<nail x="-102" y="-93"/>
			<nail x="-705" y="-93"/>
		</transition>
		<transition>
			<source ref="id26"/>
			<target ref="id27"/>
			<label kind="synchronisation" x="-688" y="-195">slotTimeout?</label>
			<label kind="assignment" x="-688" y="-178">resetBallotState()</label>
			<nail x="-484" y="-161"/>
			<nail x="-705" y="-161"/>
		</transition>
		<transition>
			<source ref="id26"/>
			<target ref="id27"/>
			<label kind="synchronisation" x="-688" y="-127">slotFail?</label>
			<label kind="assignment" x="-688" y="-110">resetBallotState()</label>
			<nail x="-484" y="-93"/>
			<nail x="-705" y="-93"/>
		</transition>
		<transition>
			<source ref="id24"/>
			<target ref="id27"/>
			<label kind="synchronisation" x="-688" y="-263">slotSuccess?</label>
			<label kind="assignment" x="-688" y="-246">resetBallotState()</label>
			<nail x="263" y="-229"/>
			<nail x="-705" y="-229"/>
		</transition>
	</template>
	<template>
		<name>NodeNomination</name>
		<parameter>const n_id nodeID</parameter>
		<declaration>//clock n_clockRound;
//bool canTickBallot = false;

//bool canFlipNomination() {
//    return protocolFlip[nodeID] &gt;= MAXGAP_PROTOCOL &amp;&amp; protocolFlip[nodeID] &lt;  MAXGAP_PROTOCOL * 2;
//}

void updateFlipNomination(bool isFlipDone) {
    if (isFlipDone || protocolFlip[nodeID] == (MAXGAP_PROTOCOL * 2) - 1) {
        protocolFlip[nodeID] = 0;
    }
    else {
        if (canFlipNomination(nodeID)) {
            protocolFlip[nodeID]++;
        }
    }
}

//bool canNextRound() {
//    int[0,MAXCNT] min = MAXCNT;

//    if (cur_round[nodeID] == MAXCNT) {
//        return false;
//    }

//    for (n : n_id) {
//       if (qs[slotCur][nodeID].validators[n] != N) {
//            if (cur_round[qs[slotCur][nodeID].validators[n]] &lt;= min) {
//                min = cur_round[qs[slotCur][nodeID].validators[n]];
//            }
//       }
//    }
//    return (cur_round[nodeID] - min) &lt; MAXGAP_NODE;
//}

void resetNominationState() {
    //removed by jyoo 20200806
    //qs[slotCur][nodeID].threshold = 0;
    //removed by jyoo 20201123
    //totalValidators[nodeID] = 0;
    cur_round[nodeID] = 0;
    tickNomination[nodeID] = 0;
    canTick[nodeID] = true;
    //n_clockRound = 0;
    //added by jyoo 20201130
    protocolFlip[nodeID] = 0;
    for (v : v_id) {
        nominatedValues[nodeID][v] = false;
        nominationStates[nodeID].voted[v] = false;
        nominationStates[nodeID].accepted[v] = false;
    }
}

void initNominationState() {
    //removed by jyoo 20201123
    //for (n : int[0,N-1]) {
    //    if (qs[slotCur][nodeID].validators[n] != N) {
    //        totalValidators[nodeID]++;
    //    }
    //}
   
    //modified by jyoo 20200806
//    if (qs[slotCur][nodeID].threshold == 0)
//        qs[slotCur][nodeID].threshold = totalValidators[nodeID]*THR/100 + 1;
    
    //added by ekjee 20200525
//    if (qs[slotCur][nodeID].threshold &gt;= totalValidators[nodeID])
//        qs[slotCur][nodeID].threshold = totalValidators[nodeID];

    //modified by ekjee 20200929
    //modified by jyoo 20201123
    int[0,N] curTotalValidators = totalValidators(nodeID);

    if (qs[slotCur][nodeID].threshold == 0)
        if ((curTotalValidators*THR/100 + 1) &gt;= curTotalValidators)
            qs[slotCur][nodeID].threshold = curTotalValidators;
        else        
            qs[slotCur][nodeID].threshold = curTotalValidators*THR/100 + 1;
}

void processMessageNomination(bool hasNominatedValues) {
    int[0,N] cntValues = 0;
    int[0,N] cntValues_qs = 0;

    // blocking threshold check for accept nomination
    for (v : v_id) {
        cntValues = 0;

        for (n : int[0,N-1]) {
            if (qs[slotCur][nodeID].validators[n] != N
                &amp;&amp; qs[slotCur][nodeID].validators[n] != nodeID
                &amp;&amp; nominationStates[qs[slotCur][nodeID].validators[n]].accepted[v]) {
                cntValues++;
            }
        }

        if (cntValues &gt; totalValidators(nodeID) - qs[slotCur][nodeID].threshold
            &amp;&amp; !nominationStates[nodeID].accepted[v]) {
            nominationStates[nodeID].accepted[v] = true;
            nominationStates[nodeID].voted[v] = false;
        }
    }

    // quorum threshold check for vote nomination
    for (v : v_id) {
        cntValues = 0;

        for (n : int[0,N-1]) {
            if (qs[slotCur][nodeID].validators[n] != N) {
                cntValues_qs = 0;

                for (n_qs : int[0,N-1]) {
                    if (qs[slotCur][qs[slotCur][nodeID].validators[n]].validators[n_qs] != N) {
                        if (nominationStates[qs[slotCur][qs[slotCur][nodeID].validators[n]].validators[n_qs]].accepted[v]) {
                            cntValues_qs++;
                        }
                        else if (nominationStates[qs[slotCur][qs[slotCur][nodeID].validators[n]].validators[n_qs]].voted[v]) {
                            cntValues_qs++;
                        }
                    }
                }

                if (cntValues_qs &gt;= qs[slotCur][qs[slotCur][nodeID].validators[n]].threshold) {
                    cntValues++;
                }
            }
        }

        if (cntValues &gt;= qs[slotCur][nodeID].threshold
            &amp;&amp; !nominationStates[nodeID].accepted[v]) {
            nominationStates[nodeID].accepted[v] = true;
            nominationStates[nodeID].voted[v] = false;
        }
    }

    // quorum threshold check for accept nomination
    for (v : v_id) {
        cntValues = 0;

        for (n : int[0,N-1]) {
            if (qs[slotCur][nodeID].validators[n] != N) {
                cntValues_qs = 0;

                for (n_qs : int[0,N-1]) {
                    if (qs[slotCur][qs[slotCur][nodeID].validators[n]].validators[n_qs] != N) {
                        if (nominationStates[qs[slotCur][qs[slotCur][nodeID].validators[n]].validators[n_qs]].accepted[v]) {
                            cntValues_qs++;
                        }
                    }
                }

                if (cntValues_qs &gt;= qs[slotCur][qs[slotCur][nodeID].validators[n]].threshold) {
                    cntValues++;
                }
            }
        }

        if (cntValues &gt;= qs[slotCur][nodeID].threshold) {
            if (!nominationStates[nodeID].accepted[v]) {
                nominationStates[nodeID].accepted[v] = true;
                nominationStates[nodeID].voted[v] = false;
            }

            if (!nominatedValues[nodeID][v]) {
                nominatedValues[nodeID][v] = true;
                if (hasNominatedValues == false) {
                    canTick[nodeID] = false;
                }
            }
        }
    }
}

int getHighestPriorityNode(int[0,MAXCNT] cur_round_in) {
    //modified by jyoo 20210131
    int[0,N] highest = cur_round_in % totalValidators(nodeID);
    int[0,N] current = 0;

    for (n : n_id) {
        if (qs[slotCur][nodeID].validators[n] != N) {
            if (current == highest) {
                return qs[slotCur][nodeID].validators[n];
            }
            else {
                current++;
            }
        }
    }

    return nodeID;
}

void getHigherlayerInput() {
    for (v : v_id) {
        if (higherlayerInput[nodeID][v]
            &amp;&amp; !nominationStates[nodeID].accepted[v]
            &amp;&amp; !nominationStates[nodeID].voted[v]) {
            nominationStates[nodeID].voted[v] = true;
            return;
        }
    }
}

void doEchoing(int[0,N] nodeIDHighest) {
    for (v : v_id) {
        if ((nominationStates[nodeIDHighest].accepted[v]
                || nominationStates[nodeIDHighest].voted[v])
            &amp;&amp; !nominationStates[nodeID].accepted[v]
            &amp;&amp; !nominationStates[nodeID].voted[v]) {
            nominationStates[nodeID].voted[v] = true;
        }
    }
}

void newRound(bool hasNominatedValues) {
    int[0,N] nodeIDHighest;

    if (tickNomination[nodeID] == cur_round[nodeID]) {
        processMessageNomination(hasNominatedValues);

        if (cur_round[nodeID]&lt;MAXCNT) {
            cur_round[nodeID]++;
        }

        if (!hasNominatedValues) {
            nodeIDHighest = getHighestPriorityNode(cur_round[nodeID]);
            if (nodeIDHighest == nodeID) {
                getHigherlayerInput();
            }
            else {
                doEchoing(nodeIDHighest);
            }
        }

        tickNomination[nodeID] = 0;
    }

    if (tickNomination[nodeID] &lt; cur_round[nodeID]) {
        tickNomination[nodeID]++;
    }

    //n_clockRound = 0;
}
</declaration>
		<location id="id36" x="153" y="0">
			<name x="17" y="-25">NominationDone</name>
		</location>
		<location id="id37" x="-187" y="0">
			<name x="-161" y="-25">SthNominated</name>
		</location>
		<location id="id38" x="-501" y="0">
			<name x="-493" y="-25">NominationStarted</name>
		</location>
		<location id="id39" x="-739" y="0">
			<name x="-722" y="-25">StartNomination</name>
		</location>
		<location id="id40" x="-501" y="195">
			<committed/>
		</location>
		<location id="id41" x="-187" y="-187">
			<committed/>
		</location>
		<location id="id42" x="-348" y="0">
			<committed/>
		</location>
		<init ref="id39"/>
		<transition>
			<source ref="id42"/>
			<target ref="id37"/>
			<label kind="synchronisation" x="-340" y="-25">sthNominated[nodeID]!</label>
		</transition>
		<transition>
			<source ref="id38"/>
			<target ref="id42"/>
			<label kind="guard" x="-467" y="17">nominatedValues[nodeID] != NOVALUE</label>
			<label kind="synchronisation" x="-467" y="34">tickAdvance[nodeID]?</label>
		</transition>
		<transition>
			<source ref="id41"/>
			<target ref="id37"/>
			<label kind="synchronisation" x="-161" y="-136">tickAdvanceBallot[nodeID]!</label>
			<nail x="-102" y="-93"/>
		</transition>
		<transition>
			<source ref="id37"/>
			<target ref="id41"/>
			<label kind="synchronisation" x="-365" y="-144">tickAdvance[nodeID]?</label>
			<label kind="assignment" x="-365" y="-127">newRound(true)</label>
			<nail x="-272" y="-93"/>
		</transition>
		<transition>
			<source ref="id40"/>
			<target ref="id38"/>
			<label kind="synchronisation" x="-501" y="110">tickAdvanceDone[nodeID]!</label>
			<nail x="-425" y="102"/>
		</transition>
		<transition>
			<source ref="id38"/>
			<target ref="id40"/>
			<label kind="guard" x="-731" y="68">nominatedValues[nodeID] == NOVALUE</label>
			<label kind="synchronisation" x="-731" y="85">tickAdvance[nodeID]?</label>
			<label kind="assignment" x="-731" y="102">newRound(false)</label>
			<nail x="-578" y="102"/>
		</transition>
		<transition>
			<source ref="id36"/>
			<target ref="id39"/>
			<label kind="synchronisation" x="-137" y="280">slotTimeout?</label>
			<label kind="assignment" x="-136" y="297">resetNominationState()</label>
			<nail x="153" y="280"/>
			<nail x="-740" y="280"/>
		</transition>
		<transition>
			<source ref="id36"/>
			<target ref="id39"/>
			<label kind="synchronisation" x="-136" y="229">slotFail?</label>
			<label kind="assignment" x="-136" y="246">resetNominationState()</label>
			<nail x="153" y="229"/>
			<nail x="-739" y="229"/>
		</transition>
		<transition>
			<source ref="id37"/>
			<target ref="id39"/>
			<label kind="synchronisation" x="-722" y="280">slotTimeout?</label>
			<label kind="assignment" x="-722" y="297">resetNominationState()</label>
			<nail x="-187" y="280"/>
			<nail x="-739" y="280"/>
		</transition>
		<transition>
			<source ref="id38"/>
			<target ref="id39"/>
			<label kind="synchronisation" x="-722" y="-187">slotTimeout?</label>
			<label kind="assignment" x="-722" y="-170">resetNominationState()</label>
			<nail x="-501" y="-153"/>
			<nail x="-739" y="-153"/>
		</transition>
		<transition>
			<source ref="id37"/>
			<target ref="id39"/>
			<label kind="synchronisation" x="-722" y="229">slotFail?</label>
			<label kind="assignment" x="-722" y="246">resetNominationState()</label>
			<nail x="-187" y="229"/>
			<nail x="-739" y="229"/>
		</transition>
		<transition>
			<source ref="id38"/>
			<target ref="id39"/>
			<label kind="synchronisation" x="-722" y="-110">slotFail?</label>
			<label kind="assignment" x="-722" y="-93">resetNominationState()</label>
			<nail x="-501" y="-76"/>
			<nail x="-739" y="-76"/>
		</transition>
		<transition>
			<source ref="id36"/>
			<target ref="id39"/>
			<label kind="synchronisation" x="-722" y="-272">slotSuccess?</label>
			<label kind="assignment" x="-722" y="-255">resetNominationState()</label>
			<nail x="153" y="-238"/>
			<nail x="-739" y="-238"/>
		</transition>
		<transition>
			<source ref="id37"/>
			<target ref="id36"/>
			<label kind="synchronisation" x="-161" y="8">nominationDone[nodeID]?</label>
			<label kind="assignment" x="-161" y="25">cur_round[nodeID] = INFINITY</label>
		</transition>
		<transition>
			<source ref="id39"/>
			<target ref="id38"/>
			<label kind="synchronisation" x="-722" y="8">slotStarted[slotCur]?</label>
			<label kind="assignment" x="-722" y="25">initNominationState()</label>
		</transition>
	</template>
	<template>
		<name>NodeSlot</name>
		<parameter>const s_id slotID</parameter>
		<declaration>int[0,N-F] cntSlotDone = 0;

bool hasHigherlayerInput() {
    for (n : n_id) {
        if (higherlayerInput[n] != NOVALUE) {
            return true;
        }
    }
    return false;
}

bool isAllAgreed(const bool &amp;value[V]) {
    for (n : n_id) {
        if (ballotStates[n].c.value != value) {
            return false;
        }
    }
    return true;
}

void clearInputs(const bool &amp;value[V]) {
    for (v : v_id) {
        if (value[v]) {
            for (n : n_id) {
                higherlayerInput[n][v] = false;
            }
        }
    }
}

void doSuccess() {
    clearInputs(ballotStates[0].c.value);
    if (slotCur &lt; SLOTMAX) {
        slotCur++;
    }
}

void doFail() {
    if (slotCur &lt; SLOTMAX) {
        slotCur++;
    }
}

//bool canNextRound(int[0,N-F-1] nID) {
//    int[0,MAXCNT] min = MAXCNT;

//    if (cur_round[nID] == MAXCNT) {
//        return false;
//    }

//    for (n : n_id) {
//        if (qs[slotCur][nID].validators[n] != N) {
//            if (cur_round[qs[slotCur][nID].validators[n]] &lt;= min) {
//                min = cur_round[qs[slotCur][nID].validators[n]];
//            }
//        }
//    }
//    return (cur_round[nID] - min) &lt; MAXGAP_NODE;
//}

//bool canNextCounter(int[0,N-F-1] nID) {
//    int[0,INFINITY] min = INFINITY;

//    if (nominatedValues[nID] == NOVALUE) {
//        return false;
//    }

//    if (ballotStates[nID].b.counter == INFINITY) {
//        return false;
//    }

//    for (n : n_id) {
//        if (qs[slotCur][nID].validators[n] != N) {
//            if (ballotStates[qs[slotCur][nID].validators[n]].b.counter &lt;= min) {
//                min = ballotStates[qs[slotCur][nID].validators[n]].b.counter;
//            }
//        }
//    }
//    return (ballotStates[nID].b.counter - min) &lt; MAXGAP_NODE;
//}

// exists (i : n_id) (cur_round[i] == MAXCNT &amp;&amp; nominatedValues[i] == NOVALUE)
// ||
// exists (i : n_id) (cur_b_cnt[i] == MAXCNT &amp;&amp; ballotStates[i].curState != SCPExternalize)
bool isSlotUnknown() {
    for (n : n_id) {
        if ((cur_round[n] == MAXCNT &amp;&amp; nominatedValues[n] == NOVALUE) || (cur_b_cnt[n] == MAXCNT &amp;&amp; ballotStates[n].curState != SCPExternalize)) {
            return true;
        }
    }
    return false;
}

bool isAllAgreedLocal(int[0,N-F-1] nID) {
    bool value[V] = NOVALUE;

    for (n : n_id) {
        if (qs[slotCur][nID].validators[n] != N) {
            if (value == NOVALUE) {
                value = ballotStates[qs[slotCur][nID].validators[n]].c.value;
            }
            else {
                if (ballotStates[qs[slotCur][nID].validators[n]].c.value != value) {
                    return false;
                }
            }
        }
    }

    return true;
}

bool isDoneNomination() {
    for (n : n_id) {
        if (cur_round[n] != INFINITY) {
            return false;
        }
    }
    return true;
}

bool isDeadlockNomination() {
    return false;

    if (isDoneNomination()) {
        return false;
    }

    for (n : n_id) {
        if (nominatedValues[n] == NOVALUE &amp;&amp; canNextRound(n)) {
            return false;
        }
        else if (nominatedValues[n] != NOVALUE &amp;&amp; cur_round[n] != INFINITY &amp;&amp; canNextRound(n) &amp;&amp; canFlipNomination(n)) {
            return false;
        }
    }
    return true;
}

bool isDoneBallot() {
    for (n : n_id) {
        if (ballotStates[n].curState != SCPExternalize) {
            return false;
        }
    }
    return true;
}

bool isDeadlockBallot() {
    if (isDoneBallot()) {
        return false;
    }

    for (n : n_id) {
        if (ballotStates[n].curState == SCPPrepare &amp;&amp; hasGEbCounter(n) &amp;&amp; canFlipBallot(n)) {
            return false;
        }
        else if (ballotStates[n].curState == SCPCommit &amp;&amp; hasGEbCounter(n)) {
            return false;
        }
    }
    return true;
}
</declaration>
		<location id="id43" x="93" y="170">
			<name x="83" y="136">SlotFail</name>
		</location>
		<location id="id44" x="93" y="-204">
			<name x="83" y="-238">SlotTimeout</name>
		</location>
		<location id="id45" x="93" y="-8">
			<name x="83" y="-42">SlotSuccess</name>
		</location>
		<location id="id46" x="-161" y="-8">
			<name x="-171" y="-42">SlotDone</name>
			<committed/>
		</location>
		<location id="id47" x="-442" y="-8">
			<name x="-527" y="0">SlotStarted</name>
		</location>
		<location id="id48" x="-722" y="-8">
			<name x="-732" y="-42">StartSlot</name>
		</location>
		<location id="id49" x="-297" y="-8">
			<committed/>
		</location>
		<init ref="id48"/>
		<transition>
			<source ref="id49"/>
			<target ref="id46"/>
			<label kind="guard" x="-306" y="8">cntSlotDone == N-F</label>
		</transition>
		<transition>
			<source ref="id49"/>
			<target ref="id47"/>
			<label kind="guard" x="-425" y="59">cntSlotDone &lt; N-F</label>
			<nail x="-365" y="51"/>
		</transition>
		<transition>
			<source ref="id47"/>
			<target ref="id49"/>
			<label kind="synchronisation" x="-408" y="-110">slotDone?</label>
			<label kind="assignment" x="-425" y="-93">cntSlotDone++</label>
			<nail x="-374" y="-68"/>
		</transition>
		<transition>
			<source ref="id46"/>
			<target ref="id43"/>
			<label kind="guard" x="-153" y="119">exists (i : n_id) !isAllAgreedLocal(i)</label>
			<label kind="synchronisation" x="-153" y="136">slotFail!</label>
			<label kind="assignment" x="-153" y="153">doFail()</label>
			<nail x="-161" y="170"/>
		</transition>
		<transition>
			<source ref="id47"/>
			<target ref="id43"/>
			<label kind="guard" x="-425" y="178">exists (i : n_id) cur_round[i] == MAXCNT
&amp;&amp; forall (i : n_id) nominationStates[i].accepted == NOVALUE</label>
			<label kind="synchronisation" x="-425" y="212">slotFail!</label>
			<label kind="assignment" x="-425" y="229">doFail()</label>
			<nail x="-442" y="170"/>
		</transition>
		<transition>
			<source ref="id47"/>
			<target ref="id44"/>
			<label kind="guard" x="-425" y="-272">exists (i : n_id) cur_round[i] == MAXCNT
|| exists (i : n_id) cur_b_cnt[i] == MAXCNT</label>
			<label kind="synchronisation" x="-425" y="-238">slotTimeout!</label>
			<label kind="assignment" x="-425" y="-221">doFail()</label>
			<nail x="-442" y="-204"/>
		</transition>
		<transition>
			<source ref="id46"/>
			<target ref="id45"/>
			<label kind="guard" x="-144" y="0">forall (i : n_id) isAllAgreedLocal(i)</label>
			<label kind="synchronisation" x="-144" y="17">slotSuccess!</label>
			<label kind="assignment" x="-144" y="34">doSuccess()</label>
		</transition>
		<transition>
			<source ref="id48"/>
			<target ref="id47"/>
			<label kind="guard" x="-705" y="0">slotCur == slotID
&amp;&amp; hasHigherlayerInput()</label>
			<label kind="synchronisation" x="-705" y="34">slotStarted[slotCur]!</label>
			<label kind="assignment" x="-705" y="51">cntSlotDone = 0</label>
		</transition>
	</template>
	<template>
		<name x="5" y="5">NodeCheckNomination</name>
		<parameter>const v_id valueID</parameter>
		<declaration>// Place local declarations here.</declaration>
		<location id="id50" x="-25" y="-170">
			<name x="-221" y="-178">CheckNominationSuccess</name>
		</location>
		<location id="id51" x="-25" y="-25">
			<name x="-212" y="-59">CheckNominationStarted</name>
		</location>
		<location id="id52" x="-416" y="-25">
			<name x="-416" y="-59">StartCheckNomination</name>
		</location>
		<init ref="id52"/>
		<transition>
			<source ref="id51"/>
			<target ref="id52"/>
			<label kind="guard" x="-399" y="93">exists (i : n_id) nominatedValues[i][valueID]
&amp;&amp; !(forall (i : n_id) nominatedValues[i][valueID])</label>
			<label kind="synchronisation" x="-399" y="76">slotDone?</label>
			<nail x="-25" y="68"/>
			<nail x="-416" y="68"/>
		</transition>
		<transition>
			<source ref="id51"/>
			<target ref="id50"/>
			<label kind="guard" x="-221" y="-127">forall (i : n_id) nominatedValues[i][valueID]</label>
			<label kind="synchronisation" x="-221" y="-144">slotDone?</label>
		</transition>
		<transition>
			<source ref="id52"/>
			<target ref="id51"/>
			<label kind="synchronisation" x="-306" y="-17">slotStarted[slotCur]?</label>
		</transition>
	</template>
	<system>//system NodeSlot, NodeNomination, NodeBallot, NodeCheckNomination;

//system TickTestApp, TickManager, TickWorker;

//system NodeSlot, NodeNomination, NodeBallot, NodeCheckNomination, TickManager, TickWorker;

system NodeSlot, NodeNomination, NodeBallot, TickManager, TickWorker;</system>
	<queries>
		<query>
			<formula>E&lt;&gt; forall (i : s_id) NodeSlot(i).SlotSuccess
			</formula>
			<comment>
			</comment>
		</query>
		<query>
			<formula>A[] forall (i : s_id) not NodeSlot(i).SlotFail
			</formula>
			<comment>
			</comment>
		</query>
		<query>
			<formula>A[] forall (i : s_id) not (NodeSlot(i).SlotFail || NodeSlot(i).SlotTimeout)
			</formula>
			<comment>
			</comment>
		</query>
		<query>
			<formula>A[] forall (i : s_id) (NodeSlot(i).SlotSuccess imply forall (j : v_id) not NodeCheckNomination(j).StartCheckNomination)
			</formula>
			<comment>
			</comment>
		</query>
		<query>
			<formula>A[] forall (i : n_id) (ballotStates[i].pp.counter == 0 &amp;&amp; ballotStates[i].pp.value == NOVALUE)</formula>
			<comment></comment>
		</query>
		<query>
			<formula>A[] forall (i : n_id) ballotStates[i].c.counter != 0 imply (ballotStates[i].c.value == ballotStates[i].h.value &amp;&amp; ballotStates[i].c.counter &lt;= ballotStates[i].h.counter) &amp;&amp; (ballotStates[i].h.value == ballotStates[i].b.value &amp;&amp; ballotStates[i].h.counter &lt;= ballotStates[i].b.counter)
			</formula>
			<comment>
			</comment>
		</query>
	</queries>
</nta>
